<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sta.20200602165810.1"><vh>project py</vh>
<v t="sta.20200608031946.1"><vh>startup</vh>
<v t="sta.20200608031546.1"><vh>scripts</vh>
<v t="sta.20200608031559.1"><vh>@script at_directory</vh></v>
</v>
<v t="sta.20200602165801.1"><vh>@settings</vh>
<v t="sta.20200602165801.470"><vh>Import options</vh>
<v t="sta.20200602165801.471"><vh>@bool add-context-to-headlines = False</vh></v>
</v>
</v>
</v>
<v t="sta.20200602110822.1"><vh>py</vh>
<v t="sta.20200612044656.1"><vh>@chapter not-included</vh>
<v t="sta.20200612045651.1"><vh>prototypes</vh></v>
<v t="sta.20200619110720.1"><vh>docs</vh>
<v t="sta.20200618151814.1"><vh>rom README</vh></v>
</v>
<v t="sta.20200612043307.1"><vh>not-working</vh>
<v t="sta.20200612055834.1"><vh>api</vh>
<v t="sta.20200616215024.1"><vh>api.pyx</vh></v>
<v t="sta.20200612055834.2"><vh>send3 (list_to_atom)</vh></v>
</v>
<v t="sta.20200612115112.1"><vh>const char* pstring_to_cstring</vh></v>
<v t="sta.20200610222640.1"><vh>t_atom* py_list_to_atom</vh></v>
<v t="sta.20200610164212.1"><vh>void py_list_to_atom2</vh></v>
<v t="sta.20200610104706.1"><vh>void py_handle_list_output2</vh></v>
</v>
<v t="sta.20200612044825.1"><vh>working</vh>
<v t="sta.20200612045044.1"><vh>api</vh>
<v t="sta.20200612044941.1"><vh>send2</vh></v>
</v>
<v t="sta.20200607084300.1"><vh>void py_exec2</vh></v>
<v t="sta.20200607084251.1"><vh>void py_eval2</vh></v>
<v t="sta.20200602120251.26"><vh>void py_globex</vh></v>
<v t="sta.20200608043930.1"><vh>void py_lookup</vh></v>
<v t="sta.20200612051513.1"><vh>void py_handle_output</vh></v>
<v t="sta.20200605120205.1"><vh>void py_locatefile</vh></v>
<v t="sta.20200610070057.1"><vh>void py_send_from_seq</vh></v>
<v t="sta.20200612114958.1"><vh>float pfloat_to_cfloat</vh></v>
<v t="sta.20200612115000.1"><vh>long plong_to_clong</vh></v>
<v t="sta.20200619105805.1"><vh>void py_pipe_c</vh></v>
<v t="sta.20200612065729.1"><vh>files</vh>
<v t="sta.20200612065752.1"><vh>@@auto globex.h</vh></v>
<v t="sta.20200612065639.1"><vh>@@auto globex.c</vh>
<v t="sta.20200612065813.1"><vh>static PyMethodDef</vh></v>
<v t="sta.20200612065813.2"><vh>static PyModuleDef</vh></v>
<v t="sta.20200612065813.3"><vh>int _add_map_to_module</vh></v>
</v>
</v>
</v>
</v>
<v t="sta.20200602164905.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20200602151837.1"><vh>@chapter notes</vh>
<v t="sta.20200602154708.1"><vh>@auto structure.txt</vh></v>
<v t="sta.20200602151900.1"><vh>@auto-md max-c-api.md</vh></v>
<v t="sta.20200602154130.1"><vh>@auto-md python-c-api.md</vh></v>
<v t="sta.20200602154301.1"><vh>@auto-md type-translation.md</vh></v>
<v t="sta.20200602154345.1"><vh>@auto-md repl.md</vh></v>
<v t="sta.20200602154429.1"><vh>@auto-md cython.md</vh></v>
<v t="sta.20200602154452.1"><vh>@auto-md packaging.md</vh></v>
<v t="sta.20200602154517.1"><vh>@auto-md scripting-tips.md</vh></v>
<v t="sta.20200602154626.1"><vh>@auto-md testing.md</vh></v>
</v>
<v t="sta.20200602164507.1"><vh>@chapter tests</vh>
<v t="sta.20200602164529.1"><vh>@clean test_translate.c</vh>
<v t="sta.20200602165143.1"><vh>declarations</vh></v>
<v t="sta.20200602165143.2"><vh>int main</vh></v>
<v t="sta.20200602165143.3"><vh>void handle_py_error</vh></v>
<v t="sta.20200602165143.4"><vh>int py_import</vh></v>
<v t="sta.20200602165143.5"><vh>int py_exec</vh></v>
<v t="sta.20200602165143.6"><vh>int py_execfile</vh></v>
<v t="sta.20200602165143.7"><vh>int py_run</vh></v>
<v t="sta.20200602165143.8"><vh>const char* py_eval_unicode</vh></v>
<v t="sta.20200602165301.1"><vh>long* py_eval_long_seq</vh></v>
<v t="sta.20200602165143.9"><vh>float* py_eval_float_seq</vh></v>
</v>
<v t="sta.20200602170210.1"><vh>@clean test_py.c</vh>
<v t="sta.20200602170222.1"><vh>declarations</vh></v>
<v t="sta.20200602170222.2"><vh>int main</vh></v>
<v t="sta.20200602170222.3"><vh>void py_import</vh></v>
<v t="sta.20200602170222.4"><vh>void py_run</vh></v>
<v t="sta.20200602170222.5"><vh>void py_execfile</vh></v>
<v t="sta.20200602170222.6"><vh>void py_exec</vh></v>
<v t="sta.20200602170222.7"><vh>void py_eval</vh></v>
</v>
<v t="sta.20200602170456.1"><vh>@clean test_minim.c</vh>
<v t="sta.20200602170556.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170513.1"><vh>@clean test_call.c</vh>
<v t="sta.20200602170550.1"><vh>int main</vh></v>
</v>
</v>
<v t="sta.20200602110836.1"><vh>@chapter src</vh>
<v t="sta.20200620071935.1"><vh>@clean api.pyx</vh>
<v t="sta.20200620071950.1"><vh>declarations</vh></v>
<v t="sta.20200620071950.3"><vh>class PyExternal</vh>
<v t="sta.20200620113654.1"><vh>declarations</vh></v>
<v t="sta.20200620071950.6"><vh>__cinit__</vh></v>
<v t="sta.20200620071950.7"><vh>bang</vh></v>
<v t="sta.20200620071950.8"><vh>log</vh></v>
<v t="sta.20200620071950.9"><vh>error</vh></v>
<v t="sta.20200620071950.10"><vh>scan</vh></v>
<v t="sta.20200620071950.11"><vh>lookup</vh></v>
<v t="sta.20200620071950.12"><vh>str</vh></v>
<v t="sta.20200620071950.13"><vh>int</vh></v>
<v t="sta.20200620071950.14"><vh>int</vh></v>
<v t="sta.20200620071950.15"><vh>send</vh></v>
<v t="sta.20200620071950.16"><vh>success</vh></v>
<v t="sta.20200620071950.17"><vh>fail</vh></v>
<v t="sta.20200620071950.18"><vh>out_sym</vh></v>
<v t="sta.20200620071950.19"><vh>out_float</vh></v>
<v t="sta.20200620071950.20"><vh>out_int</vh></v>
<v t="sta.20200620071950.21"><vh>out_list</vh></v>
<v t="sta.20200620071950.22"><vh>out_dict</vh></v>
<v t="sta.20200620071950.23"><vh>out</vh></v>
</v>
<v t="sta.20200701100646.1"><vh>module functions</vh>
<v t="sta.20200620071950.24"><vh>get_globals</vh></v>
<v t="sta.20200620112906.1"><vh>bang functions</vh>
<v t="sta.20200620071950.25"><vh>bang</vh></v>
<v t="sta.20200620071950.26"><vh>success</vh></v>
<v t="sta.20200620071950.27"><vh>fail</vh></v>
</v>
<v t="sta.20200620112807.1"><vh>typed output funcs</vh>
<v t="sta.20200620071950.28"><vh>out_sym</vh></v>
<v t="sta.20200620071950.29"><vh>out_int</vh></v>
<v t="sta.20200620071950.30"><vh>out_float</vh></v>
<v t="sta.20200620071950.31"><vh>out_list</vh></v>
<v t="sta.20200620071950.32"><vh>out_dict</vh></v>
</v>
<v t="sta.20200620113747.1"><vh>interobject funcs</vh>
<v t="sta.20200620071950.33"><vh>send</vh></v>
<v t="sta.20200620071950.34"><vh>lookup</vh></v>
</v>
<v t="sta.20200620113814.1"><vh>log functions</vh>
<v t="sta.20200620071950.39"><vh>post</vh></v>
<v t="sta.20200620071950.40"><vh>error</vh></v>
</v>
<v t="sta.20200620113843.1"><vh>demo funcs</vh>
<v t="sta.20200620071950.35"><vh>hello</vh></v>
<v t="sta.20200620071950.36"><vh>random</vh></v>
<v t="sta.20200620071950.37"><vh>echo</vh></v>
<v t="sta.20200620071950.38"><vh>total</vh></v>
</v>
<v t="sta.20200620164702.1"><vh>demo constants</vh></v>
</v>
</v>
<v t="sta.20200602145459.1"><vh>@clean py.h</vh>
<v t="sta.20200602150733.1"><vh>includes</vh></v>
<v t="sta.20200602150814.1"><vh>constants</vh></v>
<v t="sta.20200602145807.1"><vh>global variables</vh></v>
<v t="sta.20200602145517.1"><vh>object types</vh></v>
<v t="sta.20200602150052.1"><vh>function types</vh></v>
<v t="sta.20200602150129.1"><vh>enums</vh></v>
<v t="sta.20200602150250.1"><vh>macros</vh></v>
<v t="sta.20200602150324.1"><vh>methods</vh></v>
</v>
<v t="sta.20200602110841.1"><vh>@clean py.c</vh>
<v t="sta.20200602131126.1"><vh>includes</vh></v>
<v t="sta.20200602131131.1"><vh>globals</vh></v>
<v t="sta.20200602120540.1"><vh>helpers</vh>
<v t="sta.20200602120251.4"><vh>void py_log</vh></v>
<v t="sta.20200602120251.5"><vh>void py_error</vh></v>
<v t="sta.20200615052024.1"><vh>void py_init_builtins</vh></v>
<v t="sta.20200611235620.1"><vh>t_hashtab* get_global_registry</vh></v>
<v t="sta.20200615052054.1"><vh>void py_locate_path_from_symbol</vh></v>
</v>
<v t="sta.20200602120514.1"><vh>init &amp; free</vh>
<v t="sta.20200602120251.3"><vh>void ext_main</vh></v>
<v t="sta.20200602120251.7"><vh>void* py_new</vh></v>
<v t="sta.20200602120251.8"><vh>void py_init</vh></v>
<v t="sta.20200602120251.9"><vh>void py_free</vh></v>
</v>
<v t="sta.20200602121012.1"><vh>information</vh>
<v t="sta.20200602120251.10"><vh>void py_assist</vh></v>
<v t="sta.20200602122617.1"><vh>void py_count</vh></v>
</v>
<v t="sta.20200602122226.1"><vh>testing</vh>
<v t="sta.20200602122244.1"><vh>void py_bang</vh></v>
</v>
<v t="sta.20200608042323.1"><vh>common handlers</vh>
<v t="sta.20200602120251.13"><vh>void py_handle_error</vh></v>
<v t="sta.20200610181828.1"><vh>void py_handle_float_output</vh></v>
<v t="sta.20200610104609.1"><vh>void py_handle_long_output</vh></v>
<v t="sta.20200610105537.1"><vh>void py_handle_string_output</vh></v>
<v t="sta.20200610231913.1"><vh>void py_handle_list_output</vh></v>
<v t="sta.20200621080125.1"><vh>void py_handle_dict_output</vh></v>
<v t="sta.20200606044751.1"><vh>void py_handle_output</vh></v>
</v>
<v t="sta.20200610100240.1"><vh>translators</vh>
<v t="sta.20200610100158.1"><vh>PyObject* py_atom_to_list</vh></v>
</v>
<v t="sta.20200602120318.1"><vh>core</vh>
<v t="sta.20200602120251.20"><vh>void py_import</vh></v>
<v t="sta.20200602120251.21"><vh>void py_eval</vh></v>
<v t="sta.20200602120251.22"><vh>void py_exec</vh></v>
<v t="sta.20200602120251.23"><vh>void py_execfile</vh></v>
</v>
<v t="sta.20200602120740.1"><vh>extra</vh>
<v t="sta.20200602120251.25"><vh>void py_call</vh></v>
<v t="sta.20200602120251.24"><vh>void py_assign</vh></v>
<v t="sta.20200605120324.1"><vh>void py_code</vh></v>
<v t="sta.20200619105724.1"><vh>void py_pipe</vh></v>
</v>
<v t="sta.20200606073716.1"><vh>interobject</vh>
<v t="sta.20200602120251.11"><vh>void py_scan</vh></v>
<v t="sta.20200603072826.1"><vh>long py_scan_callback</vh></v>
<v t="sta.20200602120251.12"><vh>void py_send</vh></v>
</v>
<v t="sta.20200602120447.1"><vh>editor</vh>
<v t="sta.20200602120251.14"><vh>void py_dblclick</vh></v>
<v t="sta.20200602120251.15"><vh>void py_read</vh></v>
<v t="sta.20200602120251.16"><vh>void py_doread</vh></v>
<v t="sta.20200602120251.17"><vh>void py_edclose</vh></v>
<v t="sta.20200602120251.18"><vh>void py_edsave</vh></v>
<v t="sta.20200602120251.19"><vh>void py_load</vh></v>
</v>
</v>
<v t="sta.20200628230341.1"><vh>@clean pyjs.c</vh>
<v t="sta.20200628230717.1"><vh>macros</vh></v>
<v t="sta.20200628230354.1"><vh>types</vh></v>
<v t="sta.20200628230504.1"><vh>prototypes</vh></v>
<v t="sta.20200628230621.1"><vh>globals</vh></v>
<v t="sta.20200628232219.1"><vh>init and free</vh>
<v t="sta.20200628230354.2"><vh>void ext_main</vh></v>
<v t="sta.20200628230354.3"><vh>void pyjs_free</vh></v>
<v t="sta.20200628230354.4"><vh>void *pyjs_new</vh></v>
<v t="sta.20200628230354.5"><vh>void pyjs_init_builtins</vh></v>
<v t="sta.20200628230354.6"><vh>void pyjs_init</vh></v>
</v>
<v t="sta.20200628232130.1"><vh>helpers</vh>
<v t="sta.20200628230354.7"><vh>void pyjs_log</vh></v>
<v t="sta.20200628230354.8"><vh>void pyjs_error</vh></v>
<v t="sta.20200628230354.10"><vh>void pyjs_locate_path_from_symbol</vh></v>
</v>
<v t="sta.20200628232027.1"><vh>handlers</vh>
<v t="sta.20200628230354.9"><vh>void pyjs_handle_error</vh></v>
<v t="sta.20200628231456.1"><vh>t_max_err pyjs_handle_float_output</vh></v>
<v t="sta.20200628231538.1"><vh>t_max_err pyjs_handle_long_output</vh></v>
<v t="sta.20200628231613.1"><vh>t_max_err pyjs_handle_string_output</vh></v>
<v t="sta.20200628231643.1"><vh>t_max_err pyjs_handle_list_output</vh></v>
<v t="sta.20200628231714.1"><vh>t_max_err pyjs_handle_dict_output</vh></v>
<v t="sta.20200628231953.1"><vh>t_max_err pyjs_handle_output</vh></v>
</v>
<v t="sta.20200628232327.1"><vh>core message methods</vh>
<v t="sta.20200628231411.1"><vh>t_max_err pyjs_code</vh></v>
<v t="sta.20200628231428.1"><vh>t_max_err pyjs_eval</vh></v>
<v t="sta.20200628231022.1"><vh>t_max_err pyjs_execfile</vh></v>
<v t="sta.20200628231024.1"><vh>t_max_err pyjs_exec</vh></v>
</v>
<v t="sta.20200628232335.1"><vh>in-code only methods</vh>
<v t="sta.20200628231202.1"><vh>t_max_err pyjs_eval_to_json</vh></v>
</v>
</v>
<v t="sta.20200724112927.1"><vh>@clean build.py</vh>
<v t="sta.20200724112942.1"><vh>Declarations</vh></v>
<v t="sta.20200724114055.1"><vh>utility classes</vh>
<v t="sta.20200724112942.82"><vh>class DependencyManager</vh>
<v t="sta.20200724112942.83"><vh>__init__</vh></v>
<v t="sta.20200724112942.84"><vh>is_valid_path</vh></v>
<v t="sta.20200724112942.85"><vh>get_deps</vh></v>
<v t="sta.20200724112942.86"><vh>process_deps</vh></v>
<v t="sta.20200724112942.87"><vh>copy_dylibs</vh></v>
<v t="sta.20200724112942.88"><vh>change_install_names</vh></v>
<v t="sta.20200724112942.89"><vh>transform_exec</vh></v>
<v t="sta.20200724112942.90"><vh>copy_staticlibs</vh></v>
<v t="sta.20200724112942.91"><vh>process</vh></v>
</v>
</v>
<v t="sta.20200724113554.1"><vh>abstract classes</vh>
<v t="sta.20200724112942.2"><vh>class Project</vh></v>
<v t="sta.20200724112942.3"><vh>class Builder(ABC)</vh>
<v t="sta.20200724112942.4"><vh>__init__</vh></v>
<v t="sta.20200724112942.5"><vh>__repr__</vh></v>
<v t="sta.20200724112942.6"><vh>__iter__</vh></v>
<v t="sta.20200724112942.7"><vh>ver</vh></v>
<v t="sta.20200724112942.8"><vh>ver_nodot</vh></v>
<v t="sta.20200724112942.9"><vh>name_version</vh></v>
<v t="sta.20200724112942.10"><vh>name_ver</vh></v>
<v t="sta.20200724112942.11"><vh>url</vh></v>
<v t="sta.20200724112942.12"><vh>name_archive</vh></v>
<v t="sta.20200724112942.13"><vh>download_path</vh></v>
<v t="sta.20200724112942.14"><vh>src_path</vh></v>
<v t="sta.20200724112942.15"><vh>lib_path</vh></v>
<v t="sta.20200724112942.16"><vh>prefix</vh></v>
<v t="sta.20200724112942.17"><vh>prefix_lib</vh></v>
<v t="sta.20200724112942.18"><vh>prefix_include</vh></v>
<v t="sta.20200724112942.19"><vh>prefix_bin</vh></v>
<v t="sta.20200724112942.20"><vh>libs_static_exist</vh></v>
<v t="sta.20200724112942.21"><vh>cmd</vh></v>
<v t="sta.20200724112942.22"><vh>chdir</vh></v>
<v t="sta.20200724112942.23"><vh>move</vh></v>
<v t="sta.20200724112942.24"><vh>copytree</vh></v>
<v t="sta.20200724112942.25"><vh>copyfile</vh></v>
<v t="sta.20200724112942.26"><vh>remove</vh></v>
<v t="sta.20200724112942.27"><vh>reset</vh></v>
<v t="sta.20200724112942.28"><vh>download</vh></v>
<v t="sta.20200724112942.29"><vh>build</vh></v>
</v>
<v t="sta.20200724112942.30"><vh>class OSXBuilder(Builder)</vh>
<v t="sta.20200724112942.31"><vh>dylib</vh></v>
<v t="sta.20200724112942.32"><vh>download</vh></v>
</v>
</v>
<v t="sta.20200724113615.1"><vh>concrete classes</vh>
<v t="sta.20200724112942.33"><vh>class OpensslBuilder(OSXBuilder)</vh>
<v t="sta.20200724112942.34"><vh>build</vh></v>
</v>
<v t="sta.20200724112942.35"><vh>class Bzip2Builder(OSXBuilder)</vh>
<v t="sta.20200724112942.36"><vh>build</vh></v>
</v>
<v t="sta.20200724112942.37"><vh>class XzBuilder(OSXBuilder)</vh>
<v t="sta.20200724112942.38"><vh>build</vh></v>
</v>
<v t="sta.20200724112942.39"><vh>class PythonBuilder(OSXBuilder)</vh>
<v t="sta.20200724112942.40"><vh>__init__</vh></v>
<v t="sta.20200724112942.41"><vh>static_lib</vh></v>
<v t="sta.20200724112942.42"><vh>python_lib</vh></v>
<v t="sta.20200724112942.43"><vh>site_packages</vh></v>
<v t="sta.20200724112942.44"><vh>lib_dynload</vh></v>
<v t="sta.20200724112942.45"><vh>pre_process</vh></v>
<v t="sta.20200724112942.46"><vh>post_process</vh></v>
<v t="sta.20200724112942.47"><vh>write_setup_local</vh></v>
<v t="sta.20200724112942.48"><vh>apply_patch</vh></v>
<v t="sta.20200724112942.49"><vh>install</vh></v>
<v t="sta.20200724112942.50"><vh>install_python_pkg</vh></v>
<v t="sta.20200724112942.51"><vh>install_python_ext</vh></v>
<v t="sta.20200724112942.52"><vh>is_valid_path</vh></v>
<v t="sta.20200724112942.53"><vh>get_deps</vh></v>
<v t="sta.20200724112942.54"><vh>recursive_clean</vh></v>
<v t="sta.20200724112942.55"><vh>clean_python_pyc</vh></v>
<v t="sta.20200724112942.56"><vh>clean_python_tests</vh></v>
<v t="sta.20200724112942.57"><vh>rm_libs</vh></v>
<v t="sta.20200724112942.58"><vh>rm_exts</vh></v>
<v t="sta.20200724112942.59"><vh>rm_bins</vh></v>
<v t="sta.20200724112942.60"><vh>clean_python_site_packages</vh></v>
<v t="sta.20200724112942.61"><vh>remove_packages</vh></v>
<v t="sta.20200724112942.62"><vh>remove_extensions</vh></v>
<v t="sta.20200724112942.63"><vh>remove_binaries</vh></v>
<v t="sta.20200724112942.64"><vh>clean</vh></v>
<v t="sta.20200724112942.65"><vh>zip_lib</vh></v>
<v t="sta.20200724112942.66"><vh>fix_python_dylib_for_pkg</vh></v>
<v t="sta.20200724112942.67"><vh>fix_python_dylib_for_ext</vh></v>
<v t="sta.20200724112942.68"><vh>pre_process</vh></v>
<v t="sta.20200724112942.69"><vh>post_process</vh></v>
</v>
<v t="sta.20200724112942.70"><vh>class StaticPythonBuilder(PythonBuilder)</vh>
<v t="sta.20200724112942.71"><vh>prefix</vh></v>
<v t="sta.20200724112942.72"><vh>build</vh></v>
<v t="sta.20200724112942.73"><vh>post_process</vh></v>
</v>
<v t="sta.20200724112942.74"><vh>class SharedPythonBuilder(PythonBuilder)</vh>
<v t="sta.20200724112942.75"><vh>prefix</vh></v>
<v t="sta.20200724112942.76"><vh>build</vh></v>
<v t="sta.20200724112942.77"><vh>remove_extensions</vh></v>
</v>
<v t="sta.20200724112942.78"><vh>class FrameworkPythonBuilder(PythonBuilder)</vh>
<v t="sta.20200724112942.79"><vh>prefix</vh></v>
<v t="sta.20200724112942.80"><vh>build</vh></v>
<v t="sta.20200724112942.81"><vh>remove_extensions</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sta.20200602110822.1"></t>
<t tx="sta.20200602110836.1">@path source/py</t>
<t tx="sta.20200602110841.1">// py.c

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602120251.10">void py_assist(t_py* x, void* b, long m, long a, char* s)
{
    if (m == ASSIST_INLET) { // inlet
        sprintf(s, "I am inlet %ld", a);
    } else { // outlet
        sprintf(s, "I am outlet %ld", a);
    }
}
</t>
<t tx="sta.20200602120251.11">void py_scan(t_py* x)
{
    long result = 0;

    hashtab_clear(py_global_registry);

    if (x-&gt;p_patcher == NULL) {
        post("p_patcher == NULL");
    } else {
        post("p_patcher != NULL");
    }

    if (x-&gt;p_patcher) {
        object_method(x-&gt;p_patcher, gensym("iterate"),
                      (method)py_scan_callback, x, PI_DEEP | PI_WANTBOX,
                      &amp;result);
    } else {
        py_error(x, "scan failed");
    }
}


</t>
<t tx="sta.20200602120251.12">void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    t_object* obj = NULL;
    char* obj_name = NULL;
    t_symbol* msg_sym = NULL;
    t_max_err err = NULL;

    if (argc &lt; 2) {
        py_error(x, "need at least 2 args to send msg");
        goto error;
    }

    if ((argv + 0)-&gt;a_type != A_SYM) {
        py_error(
            x, "1st arg of send needs to be a symbol name of receiver object");
        goto error;
    }

    // argv+0 is the object name to send to
    obj_name = atom_getsym(argv)-&gt;s_name;
    if (obj_name == NULL) {
        goto error;
    }

    // if registry is empty, scan it
    if (hashtab_getsize(py_global_registry) == 0) {
        py_scan(x);
    }

    // // lookup name in registry
    err = hashtab_lookup(py_global_registry, gensym(obj_name), &amp;obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found in the registry");
        goto error;
    }

    // atom after the name of the receiver
    switch ((argv + 1)-&gt;a_type) {
    case A_SYM: {
        msg_sym = atom_getsym(argv + 1);
        if (msg_sym == NULL) { // should check type here
            goto error;
        }
        // address the minimum case: e.g a bang
        if (argc - 2 == 0) { //
            argc = 0;
            argv = NULL;
        } else {
            argc = argc - 2;
            argv = argv + 2;
        }
        break;
    }
    case A_FLOAT: {
        msg_sym = gensym("float");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        argv = argv + 1;

        break;
    }
    case A_LONG: {
        msg_sym = gensym("int");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        argv = argv + 1;

        break;
    }
    default:
        py_log(x, "cannot process unknown type");
        break;
    }

    // methods to get method type
    t_messlist* messlist = object_mess((t_object*)obj, msg_sym);
    if (messlist) {
        post("messlist-&gt;m_sym  (name of msg): %s", messlist-&gt;m_sym-&gt;s_name);
        post("messlist-&gt;m_type (type of msg): %d", messlist-&gt;m_type[0]);
    }

    err = object_method_typed(obj, msg_sym, argc, argv, NULL);
    if (err) {
        py_error(x, "failed to send a message to object %s", obj_name);
        goto error;
    }

    // success
    return;

error:
    py_error(x, "send failed");
    return;
}

</t>
<t tx="sta.20200602120251.13">void py_handle_error(t_py* x, char* fmt, ...)
{
    if (PyErr_Occurred()) {

        // build custom msg
        char msg[PY_MAX_ERR_CHAR];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        // get error info
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        PyErr_NormalizeException(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        Py_XDECREF(ptype);

        PyObject* pvalue_pstr = PyObject_Repr(pvalue);
        const char* pvalue_str = PyUnicode_AsUTF8(pvalue_pstr);
        Py_XDECREF(pvalue);
        Py_XDECREF(pvalue_pstr);

        Py_XDECREF(ptraceback);

        error("[py %s] %s: %s", x-&gt;p_name-&gt;s_name, msg, pvalue_str);
    }
}


</t>
<t tx="sta.20200602120251.14">void py_dblclick(t_py* x)
{
    if (x-&gt;p_code_editor)
        object_attr_setchar(x-&gt;p_code_editor, gensym("visible"), 1);
    else {
        x-&gt;p_code_editor = object_new(CLASS_NOBOX, gensym("jed"), x, 0);
        object_method(x-&gt;p_code_editor, gensym("settext"), *x-&gt;p_code,
                      gensym("utf-8"));
        object_attr_setchar(x-&gt;p_code_editor, gensym("scratch"), 1);
        object_attr_setsym(x-&gt;p_code_editor, gensym("title"),
                           gensym("py-editor"));
    }
}


</t>
<t tx="sta.20200602120251.15">void py_read(t_py* x, t_symbol* s)
{
    defer((t_object*)x, (method)py_doread, s, 0, NULL);
}


</t>
<t tx="sta.20200602120251.16">void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    t_max_err err;
    t_filehandle fh;

    py_locate_path_from_symbol(x, s);
    err = path_opensysfile(x-&gt;p_code_filename, x-&gt;p_code_path, &amp;fh, READ_PERM);
    if (!err) {
        sysfile_readtextfile(fh, x-&gt;p_code, 0,
                             TEXT_LB_UNIX | TEXT_NULL_TERMINATE);
        sysfile_close(fh);
        x-&gt;p_code_size = sysmem_handlesize(x-&gt;p_code);
    }
}


</t>
<t tx="sta.20200602120251.17">void py_edclose(t_py* x, char** text, long size)
{
    if (x-&gt;p_code)
        sysmem_freehandle(x-&gt;p_code);

    x-&gt;p_code = sysmem_newhandleclear(size + 1);
    sysmem_copyptr((char*)*text, *x-&gt;p_code, size);
    x-&gt;p_code_size = size + 1;
    x-&gt;p_code_editor = NULL;
}


</t>
<t tx="sta.20200602120251.18">void py_run(t_py* x)
{
    PyObject* pval = NULL;

    if ((*(x-&gt;p_code) != NULL) &amp;&amp; (*(x-&gt;p_code)[0] == '\0'))
        // is empty string
        goto error;

    pval = PyRun_String(*(x-&gt;p_code), Py_file_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "run x-&gt;p_code failed");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}


// void py_okclose(t_py* x, char *s, short *result)
// {
//     // see: https://cycling74.com/forums/text-editor-without-dirty-bit
//     py_log(x, "okclose: called");
//     *result = 3; // don't put up a dialog
// } 


long py_edsave(t_py* x, char** text, long size)
{
    PyObject* pval = NULL;

    if (x-&gt;p_run_on_save) {

        py_log(x, "run-on-save activated");
        
        pval = PyRun_String(*text, Py_file_input, x-&gt;p_globals, x-&gt;p_globals);
        if (pval == NULL) {
            py_error(x, "py_edsave: pval == NULL");
            goto error;
        }

        // success cleanup
        Py_DECREF(pval);
    }
    py_log(x, "py_edsave: returning 0");
    return 0;

error:
    py_handle_error(x, "py_edsave with (possible) execution failed");
    Py_XDECREF(pval);
    py_log(x, "py_edsave: returning 1");
    return 1;
}



</t>
<t tx="sta.20200602120251.19">void py_load(t_py* x, t_symbol* s)
{
    py_read(x, s);
    py_execfile(x, s);
}
</t>
<t tx="sta.20200602120251.20">void py_import(t_py* x, t_symbol* s)
{
    PyObject* x_module = NULL;

    if (s != gensym("")) {
        x_module = PyImport_ImportModule(s-&gt;s_name);
        // x_module borrrowed ref
        if (x_module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, s-&gt;s_name, x_module);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "imported: %s", s-&gt;s_name);
    }
    return;

error:
    py_handle_error(x, "import %s", s-&gt;s_name);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200602120251.21">void py_eval(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* py_argv = atom_getsym(argv)-&gt;s_name;
    py_log(x, "%s %s", s-&gt;s_name, py_argv);

    PyObject* pval = PyRun_String(py_argv, Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);

    if (pval != NULL) {
        py_handle_output(x, pval);
        return;
    } else {
        py_handle_error(x, "eval %s", py_argv);
        outlet_bang(x-&gt;p_outlet_middle);
    }
}


</t>
<t tx="sta.20200602120251.22">void py_exec(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* py_argv = NULL;
    PyObject* pval = NULL;

    py_argv = atom_getsym(argv)-&gt;s_name;
    if (py_argv == NULL) {
        goto error;
    }

    pval = PyRun_String(py_argv, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    outlet_bang(x-&gt;p_outlet_right);

    // success cleanup
    Py_DECREF(pval);
    py_log(x, "exec %s", py_argv);
    return;

error:
    py_handle_error(x, "exec %s", py_argv);
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200602120251.23">void py_execfile(t_py* x, t_symbol* s)
{

    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (s != gensym("")) {
        // set x-&gt;p_code_filepath
        py_locate_path_from_symbol(x, s);
    }

    if (s == gensym("") || x-&gt;p_code_filepath == gensym("")) {
        py_error(x, "could not set filepath");
        goto error;
    }

    // assume x-&gt;p_code_filepath has be been set without errors

    py_log(x, "pathname: %s", x-&gt;p_code_filepath-&gt;s_name);
    fhandle = fopen(x-&gt;p_code_filepath-&gt;s_name, "r+");

    if (fhandle == NULL) {
        py_error(x, "could not open file");
        goto error;
    }

    pval = PyRun_File(fhandle, x-&gt;p_code_filepath-&gt;s_name, Py_file_input,
                      x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "execfile");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.24">void py_assign(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* varname = NULL;
    PyObject* list = NULL;

    if (s != gensym(""))
        py_log(x, "s: %s", s-&gt;s_name);

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        varname = atom_getsym(argv)-&gt;s_name;
        py_log(x, "varname: %s", varname);
    }

    list = py_atoms_to_list(x, argc, argv, 1);
    if (list == NULL) {
        py_error(x, "atom to py list conversion failed");
        goto error;
    }

    if (PyList_Size(list) != argc - 1) {
        py_error(x, "PyList_Size(list) != argc - 1");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(list));
    }

    // finally, assign list to varname in object namespace
    py_log(x, "setting %s to list in namespace", varname);
    int res = PyDict_SetItemString(x-&gt;p_globals, varname, list);
    if (res != 0) {
        py_error(x, "assign varname to list failed");
        goto error;
    }
    // Py_XDECREF(list); // causes a crash
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "assign %s", s-&gt;s_name);
    Py_XDECREF(list);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200602120251.25">void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* callable_name = NULL;
    PyObject* py_argslist = NULL;
    PyObject* pval = NULL;
    PyObject* py_callable = NULL;
    // python list
    PyObject* py_args = NULL; // python tuple

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        callable_name = atom_getsym(argv)-&gt;s_name;
        py_log(x, "callable_name: %s", callable_name);
    }

    py_callable = PyRun_String(callable_name, Py_eval_input, x-&gt;p_globals,
                               x-&gt;p_globals);
    if (py_callable == NULL) {
        py_error(x, "could not evaluate %s", callable_name);
        goto error;
    }

    py_argslist = py_atoms_to_list(x, argc, argv, 1);
    if (py_argslist == NULL) {
        py_error(x, "atom to py list conversion failed");
        goto error;
    }

    py_log(x, "length of argc:%ld list: %d", argc, PyList_Size(py_argslist));

    // convert py_args to tuple
    py_args = PyList_AsTuple(py_argslist);
    if (py_args == NULL) {
        py_error(x, "unable to convert args list to tuple");
        goto error;
    }

    // pval = PyObject_Call(py_callable, py_args, NULL);
    pval = PyObject_CallObject(py_callable, py_args);
    if (!PyErr_ExceptionMatches(PyExc_TypeError)) {
        if (pval == NULL) {
            py_error(x, "unable to apply callable(*args)");
            goto error;
        }
        goto handle_output;
    }
    PyErr_Clear();

    pval = PyObject_CallFunctionObjArgs(py_callable, py_argslist, NULL);
    if (pval == NULL) {
        py_error(x, "could not retrieve result of callable(list)");
        goto error;
    }
    goto handle_output; // this is redundant but safer in case code is added

handle_output:

    py_handle_output(x, pval);
    // success cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    py_log(x, "END %s", s-&gt;s_name);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:

    py_handle_error(x, "anything %s", s-&gt;s_name);
    // cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200602120251.26">/*
needs the following above Py_Initialize;

if (PyImport_AppendInittab("globex", PyInit_globex) == -1) {
    py_error(x, "could not add globex to builtin modules table");
}

*/


void py_globex(t_py* x, long n)
{
    PyObject* globex_mod = NULL;

    globex_mod = PyImport_ImportModule("globex"); // x_module borrrowed ref
    if (globex_mod == NULL) {
        goto error;
    }

    PyDict_SetItemString(x-&gt;p_globals, "globex", globex_mod);

    PyObject* globex_dict = PyModule_GetDict(globex_mod);

    if (PyDict_SetItemString(globex_dict, NAME_INT, PyLong_FromLong(n))
        == -1) {
        py_error(x, "cannot set long to NAME_INT");
        goto error;
    }

    outlet_bang(x-&gt;p_outlet_right);
    py_log(x, "globex import and globex.INT = %ld", n);
    return;
error:
    py_handle_error(x, "globex %ld", n);
    outlet_bang(x-&gt;p_outlet_middle);
}
</t>
<t tx="sta.20200602120251.3">void ext_main(void* r)
{
    t_class* c;

    c = class_new("py", (method)py_new, (method)py_free, (long)sizeof(t_py),
                  0L, A_GIMME, 0);

    // object methods
    //------------------------------------------------------------------------
    // clang-format off

    // testing
    class_addmethod(c, (method)py_bang,       "bang",                  0);

    // core
    class_addmethod(c, (method)py_import,     "import",     A_SYM,     0);
    class_addmethod(c, (method)py_eval,       "eval",       A_GIMME,   0);
    class_addmethod(c, (method)py_exec,       "exec",       A_GIMME,   0);
    class_addmethod(c, (method)py_execfile,   "execfile",   A_DEFSYM,  0);

    // core extra
    class_addmethod(c, (method)py_assign,     "assign",     A_GIMME,   0);
    class_addmethod(c, (method)py_call,       "call",       A_GIMME,   0);
    class_addmethod(c, (method)py_code,       "code",       A_GIMME,   0);
    class_addmethod(c, (method)py_pipe,       "pipe",       A_GIMME,   0);
    class_addmethod(c, (method)py_anything,   "anything",   A_GIMME,   0);

    // meta
    class_addmethod(c, (method)py_assist,     "assist",     A_CANT,    0);
    class_addmethod(c, (method)py_count,      "count",      A_NOTHING, 0);

    // interobject
    class_addmethod(c, (method)py_scan,       "scan",       A_NOTHING, 0);
    class_addmethod(c, (method)py_send,       "send",       A_GIMME,   0);

    // code editor
    class_addmethod(c, (method)py_read,       "read",       A_DEFSYM,  0);
    class_addmethod(c, (method)py_dblclick,   "dblclick",   A_CANT,    0);
    class_addmethod(c, (method)py_edclose,    "edclose",    A_CANT,    0);
    class_addmethod(c, (method)py_edsave,     "edsave",     A_CANT,    0);
    class_addmethod(c, (method)py_load,       "load",       A_DEFSYM,  0);
    class_addmethod(c, (method)py_run,        "run",        A_NOTHING, 0);
    // class_addmethod(c, (method)py_okclose,    "okclose",    A_CANT,    0);

    // experimental
    class_addmethod(c, (method)py_appendtodict,  "appendtodictionary",  A_CANT, 0);

    // object attributes
    //------------------------------------------------------------------------

    CLASS_ATTR_LABEL(c, "name", 0,  "unique object id");
    CLASS_ATTR_SYM(c,   "name", 0,   t_py, p_name);
    CLASS_ATTR_BASIC(c, "name", 0);
    // CLASS_ATTR_INVISIBLE(c, "name", 0);

    CLASS_ATTR_LABEL(c,  "file", 0,  "default python script");
    CLASS_ATTR_SYM(c,    "file", 0,   t_py,  p_code_filepath);
    CLASS_ATTR_STYLE(c,  "file", 0,   "file");
    CLASS_ATTR_BASIC(c,  "file", 0);
    CLASS_ATTR_SAVE(c,   "file", 0);

    CLASS_ATTR_LABEL(c,  "autoload", 0,  "autoload default python script");
    CLASS_ATTR_CHAR(c,   "autoload", 0,  t_py, p_autoload);
    CLASS_ATTR_STYLE(c,  "autoload", 0, "onoff");
    CLASS_ATTR_BASIC(c,  "autoload", 0);
    CLASS_ATTR_SAVE(c,   "autoload", 0);

    CLASS_ATTR_LABEL(c,  "run_on_save", 0,  "run content of editor on save");
    CLASS_ATTR_CHAR(c,   "run_on_save", 0,  t_py, p_run_on_save);
    CLASS_ATTR_STYLE(c,  "run_on_save", 0, "onoff");
    CLASS_ATTR_BASIC(c,  "run_on_save", 0);
    CLASS_ATTR_SAVE(c,   "run_on_save", 0);

    CLASS_ATTR_LABEL(c,  "pythonpath", 0,  "per-object pythonpath");
    CLASS_ATTR_SYM(c,    "pythonpath", 0,  t_py, p_pythonpath);
    CLASS_ATTR_STYLE(c,  "pythonpath", 0,  "file");
    CLASS_ATTR_BASIC(c,  "pythonpath", 0);
    CLASS_ATTR_SAVE(c,   "pythonpath", 0);

    CLASS_ATTR_LABEL(c,  "debug", 0,  "debug log to console");
    CLASS_ATTR_CHAR(c,   "debug", 0,  t_py, p_debug);
    CLASS_ATTR_STYLE(c,  "debug", 0, "onoff");
    CLASS_ATTR_BASIC(c,  "debug", 0);
    CLASS_ATTR_SAVE(c,   "debug", 0);

    CLASS_ATTR_ORDER(c,  "name",        0,  "1");
    CLASS_ATTR_ORDER(c,  "file",        0,  "2");
    CLASS_ATTR_ORDER(c,  "autoload",    0,  "3");
    CLASS_ATTR_ORDER(c,  "run_on_save", 0,  "4");
    CLASS_ATTR_ORDER(c,  "pythonpath",  0,  "5");
    CLASS_ATTR_ORDER(c,  "debug",       0,  "6");

    // clang-format on
    //------------------------------------------------------------------------

    class_register(CLASS_BOX, c);

    /* for js registration (can't be both box and nobox) */
    // c-&gt;c_flags = CLASS_FLAG_POLYGLOT;
    // class_register(CLASS_NOBOX, c);

    py_class = c;
}


</t>
<t tx="sta.20200602120251.4">void py_log(t_py* x, char* fmt, ...)
{
    if (x-&gt;p_debug) {
        char msg[PY_MAX_LOG_CHAR];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        post("[py %s]: %s", x-&gt;p_name-&gt;s_name, msg);
    }
}


</t>
<t tx="sta.20200602120251.5">void py_error(t_py* x, char* fmt, ...)
{
    char msg[PY_MAX_ERR_CHAR];

    va_list va;
    va_start(va, fmt);
    vsprintf(msg, fmt, va);
    va_end(va);

    error("[py %s]: %s", x-&gt;p_name-&gt;s_name, msg);
}


</t>
<t tx="sta.20200602120251.7">void* py_new(t_symbol* s, long argc, t_atom* argv)
{
    t_py* x = NULL;

    x = (t_py*)object_alloc(py_class);

    if (x) {

        if (py_global_obj_count == 0) {
            // first py obj is called '__main__'
            x-&gt;p_name = gensym("__main__");
        } else {
            x-&gt;p_name = symbol_unique();
        }
        // x-&gt;p_name = symbol_unique();

        // communication
        x-&gt;p_patcher = NULL;
        x-&gt;p_box = NULL;

        // python-related
        x-&gt;p_pythonpath = gensym("");

        // text editor
        x-&gt;p_code = sysmem_newhandle(0);
        x-&gt;p_code_size = 0;
        x-&gt;p_code_editor = NULL;
        x-&gt;p_code_filetype = FOUR_CHAR_CODE('TEXT');
        x-&gt;p_code_outtype = 0;
        x-&gt;p_code_filename[0] = 0;
        x-&gt;p_code_pathname[0] = 0;
        // short p_code_path;
        x-&gt;p_code_filepath = gensym("");
        x-&gt;p_autoload = 0;
        x-&gt;p_run_on_save = 0;

        // set default debug level
        x-&gt;p_debug = 1;

        // create inlet(s)
        // create outlet(s)
        x-&gt;p_outlet_right = outlet_new(x, NULL);
        x-&gt;p_outlet_middle = outlet_new(x, NULL);
        x-&gt;p_outlet_left = outlet_new(x, NULL);

        // process @arg attributes
        attr_args_process(x, argc, argv);

        object_obex_lookup(x, gensym("#P"), (t_patcher**)&amp;x-&gt;p_patcher);
        if (x-&gt;p_patcher == NULL)
            error("patcher object not created.");

        object_obex_lookup(x, gensym("#B"), (t_box**)&amp;x-&gt;p_box);
        if (x-&gt;p_box == NULL)
            error("patcher object not created.");

        // create scripting name
        t_max_err err = jbox_set_varname(x-&gt;p_box, x-&gt;p_name);
        if (err != MAX_ERR_NONE) {
            error("could not set scripting name");
        }

        // python init
        py_init(x);

        py_log(x, "object created");
        for (int i = 0; i &lt; argc; i++) {
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            post("argc: %d  argv: %s", i, atom_getsym(argv + i)-&gt;s_name);
        }

        t_dictionary* dict = (t_dictionary*)gensym("#D")-&gt;s_thing;
        if (dict) {
            dictionary_getsym(dict, gensym("file"), &amp;x-&gt;p_code_filepath);
            dictionary_getlong(dict, gensym("autoload"),
                               (t_atom_long*)&amp;x-&gt;p_autoload);
            dictionary_getsym(dict, gensym("pythonpath"), &amp;x-&gt;p_pythonpath);
        }
    }

    // process autoload
    py_log(x, "checking autoload / code_filepath / pythonpath");
    py_log(x, "autoload: %d\ncode_filepath: %s\npythonpath: %s", x-&gt;p_autoload,
           x-&gt;p_code_filepath-&gt;s_name, x-&gt;p_pythonpath-&gt;s_name);
    py_log(x, "via object_attr_getsym: %s",
           object_attr_getsym(x, gensym("file"))-&gt;s_name);

    if ((x-&gt;p_autoload == 1) &amp;&amp; (x-&gt;p_code_filepath != gensym(""))) {
        py_log(x, "autoloading: %s", x-&gt;p_code_filepath-&gt;s_name);
        py_load(x, x-&gt;p_code_filepath);
    }

    if (x-&gt;p_pythonpath != gensym("")) {
        PyObject* sys_path = PySys_GetObject((char*)"path");
        PyObject* py_path = PyUnicode_FromString(x-&gt;p_pythonpath-&gt;s_name);
        PyList_Append(sys_path, py_path);
    }

    return (x);
}

</t>
<t tx="sta.20200602120251.8">void py_init(t_py* x)
{
    #ifdef PY_STATIC_EXT
    wchar_t *python_home;
    // char path[150];

    // method 1
    CFBundleRef bundle;
    CFURLRef resources_url;
    CFURLRef resources_abs_url;
    CFStringRef resources_str;
    const char* resources_path;

    // Look for a bundle using its identifier
    bundle = CFBundleGetBundleWithIdentifier(CFSTR("org.me.py"));
    resources_url = CFBundleCopyResourcesDirectoryURL(bundle);
    resources_abs_url = CFURLCopyAbsoluteURL(resources_url);
    resources_str = CFURLCopyFileSystemPath(resources_abs_url, kCFURLPOSIXPathStyle);
    resources_path = CFStringGetCStringPtr(resources_str, kCFStringEncodingUTF8);
    python_home = Py_DecodeLocale(resources_path, NULL);    

    // CFRelease(resources_url);
    // CFRelease(resources_abs_url);
    // CFRelease(resources_str);
    // CFRelease(resources_path);

    // STRANGE: if I run the next line the python_home isn't set properly!!
    // char* exec_path = Py_EncodeLocale(Py_GetProgramFullPath(), NULL);
    // sprintf(path, "%s/Resources", dirname(dirname(exec_path)));
    // python_home = Py_DecodeLocale(path, NULL);

    post("resources_path: %s", resources_path);
    // python_home = Py_DecodeLocale("&lt;abs-path-to-Resources&gt;", NULL);
    if (python_home == NULL) {
        error("python_home is NULL");
        // return;
    }
    Py_SetPythonHome(python_home);

    // wchar_t *program;
    // program = Py_DecodeLocale("py", NULL);
    // if (program == NULL) {
    //     exit(1);
    // }

    // Py_SetProgramName(program);
    #endif


    /* Add the cythonized 'api' built-in module, before Py_Initialize */
    if (PyImport_AppendInittab("api", PyInit_api) == -1) {
        py_error(x, "could not add api to builtin modules table");
    }


    Py_Initialize();

    // python init
    PyObject* main_mod = PyImport_AddModule(x-&gt;p_name-&gt;s_name); // borrowed
    x-&gt;p_globals = PyModule_GetDict(main_mod); // borrowed reference
    py_init_builtins(x); // does this have to be a separate function?

    // register the object
    object_register(CLASS_BOX, x-&gt;p_name, x);

    // increment global object counter
    py_global_obj_count++;

    if (py_global_obj_count == 1) {
        // if first py object create the py_global_registry;
        py_global_registry = (t_hashtab*)hashtab_new(0);
        hashtab_flags(py_global_registry, OBJ_FLAG_REF);
    }
}


</t>
<t tx="sta.20200602120251.9">void py_free(t_py* x)
{
    // code editor cleanup
    object_free(x-&gt;p_code_editor);
    if (x-&gt;p_code)
        sysmem_freehandle(x-&gt;p_code);

    // delete api object
    // PyObject* api = PyDict_GetItemString(x-&gt;p_globals, "api");
    // if (api != NULL) {
    //     PyModuleDef* api_def = PyModule_GetDef(api);
    //     if (PyState_RemoveModule(api_def) == 0) {
    //         py_log(x, "removed api module");
    //     }
    //     if (PyDict_DelItemString(x-&gt;p_globals, "api") == 0) {
    //         py_log(x, "removed ref to api module in globals");
    //     }
    // }

    Py_XDECREF(x-&gt;p_globals);
    // python objects cleanup
    py_log(x, "will be deleted");
    py_global_obj_count--;
    if (py_global_obj_count == 0) {
        /* WARNING: don't call x here or max will crash */
        hashtab_chuck(py_global_registry);

        post("last py obj freed -&gt; finalizing py mem / interpreter.");
        // PyMem_RawFree(program);
        Py_FinalizeEx();
    }
}

</t>
<t tx="sta.20200602120318.1">/*--------------------------------------------------------------------------*/
// CORE

</t>
<t tx="sta.20200602120447.1">/*--------------------------------------------------------------------------*/
// EDITOR

</t>
<t tx="sta.20200602120514.1">/*--------------------------------------------------------------------------*/
// INIT &amp; FREE

</t>
<t tx="sta.20200602120540.1">/*--------------------------------------------------------------------------*/
// HELPERS

// WARNING: if PY_MAX_LOG_CHAR (which defines PY_MAX_ERR_CHAR) is too low
// long log or err messages will crash

</t>
<t tx="sta.20200602120740.1">/*--------------------------------------------------------------------------*/
// EXTRA

</t>
<t tx="sta.20200602121012.1">/*--------------------------------------------------------------------------*/
// DOCUMENTATION

</t>
<t tx="sta.20200602122226.1">/*--------------------------------------------------------------------------*/
// TESTING
</t>
<t tx="sta.20200602122244.1">
void py_bang(t_py* x)
{
    // just a basic bang out the left outlet method
    outlet_bang(x-&gt;p_outlet_left);
}

</t>
<t tx="sta.20200602122617.1">

void py_count(t_py* x) { outlet_int(x-&gt;p_outlet_left, py_global_obj_count); }

</t>
<t tx="sta.20200602131126.1">/*--------------------------------------------------------------------------*/
// INCLUDES

/* py external api */
#include "py.h"

/* max/msp api */
#include "api.h"

#ifdef PY_STATIC_EXT
#include &lt;libgen.h&gt;
#endif

</t>
<t tx="sta.20200602131131.1">/*--------------------------------------------------------------------------*/
// GLOBALS

t_class* py_class; // global pointer to object class

static int py_global_obj_count = 0; // when 0 then free interpreter

static t_hashtab* py_global_registry = NULL; // global object lookups

// static wchar_t* program;

</t>
<t tx="sta.20200602145459.1">#ifndef PY_H
#define PY_H

/* py.h */

@others
@language c
@tabwidth -4
#endif // PY_H
</t>
<t tx="sta.20200602145517.1">/*--------------------------------------------------------------------------*/
// OBJECT TYPES

typedef struct _py {
    /* object header */
    t_object p_ob;

    /* object attributes */
    t_symbol* p_name; /* unique object name */

    /* python-related */
    t_symbol* p_pythonpath; /* path to python directory */
    t_bool p_debug;         /* bool to switch per-object debug state */
    PyObject* p_globals;    /* per object 'globals' python namespace */

    /* infra objects */
    t_patcher* p_patcher; /* to send msgs to objects */
    t_box* p_box;         /* the ui box of the py instance? */

    /* text editor attrs */
    t_object* p_code_editor;
    char** p_code;
    long p_code_size;

    t_fourcc p_code_filetype; // = FOUR_CHAR_CODE('TEXT')
    t_fourcc p_code_outtype;  // = FOUR_CHAR_CODE('TEXT')
    char p_code_filename[MAX_PATH_CHARS];
    char p_code_pathname[MAX_PATH_CHARS];
    short p_code_path;
    t_bool p_run_on_save;

    t_symbol* p_code_filepath; /* default python filepath to load into
                                  the code editor and object 'globals'
                                  namespace */
    t_bool p_autoload;         /* bool to autoload of p_code_filepath  */

    /* outlet creation */
    void* p_outlet_right;  // right outlet to bang success
    void* p_outlet_middle; // middle outleet to bang error
    void* p_outlet_left;   // left outleet for msg output

} t_py;

</t>
<t tx="sta.20200602145807.1">/*--------------------------------------------------------------------------*/
// GLOBALS

t_class* py_class;                    // global pointer to object class
static int py_global_obj_count;       // when 0 then free interpreter
static t_hashtab* py_global_registry; // global object lookups
</t>
<t tx="sta.20200602150052.1">/*--------------------------------------------------------------------------*/
// FUNCTION TYPES
</t>
<t tx="sta.20200602150129.1">/*--------------------------------------------------------------------------*/
// ENUMS
</t>
<t tx="sta.20200602150250.1">/*--------------------------------------------------------------------------*/
// MACROS
</t>
<t tx="sta.20200602150324.1">/*--------------------------------------------------------------------------*/
// METHODS

/* object creation and destruction */
void* py_new(t_symbol* s, long argc, t_atom* argv);
void py_free(t_py* x);
void py_init(t_py* x);

/* helpers */
void py_log(t_py* x, char* fmt, ...);
void py_error(t_py* x, char* fmt, ...);
void py_init_builtins(t_py* x);
void py_locate_path_from_symbol(t_py* x, t_symbol* s);
t_hashtab* get_global_registry(void);

/* common handlers */
void py_handle_error(t_py* x, char* fmt, ...);
void py_handle_float_output(t_py* x, PyObject* pval);
void py_handle_long_output(t_py* x, PyObject* pval);
void py_handle_string_output(t_py* x, PyObject* pval);
void py_handle_list_output(t_py* x, PyObject* pval);
void py_handle_dict_output(t_py* x, PyObject* pval);
void py_handle_output(t_py* x, PyObject* pval);

/* core python methods */
void py_import(t_py* x, t_symbol* s);
void py_eval(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_exec(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_execfile(t_py* x, t_symbol* s);

/* extra python methods */
void py_assign(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_code(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_pipe(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_anything(t_py* x, t_symbol* s, long argc, t_atom* argv);

/* informational */
void py_count(t_py* x);
void py_assist(t_py* x, void* b, long m, long a, char* s);
void py_appendtodict(t_py* x, t_dictionary* dict);

/* testing */
void py_bang(t_py* x);

/* interobject communications */
void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_scan(t_py* x);
long py_scan_callback(t_py* x, t_object* obj);

/* code editor */
void py_read(t_py* x, t_symbol* s);
void py_load(t_py* x, t_symbol* s); // read(f) -&gt; execfile(f)
void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_dblclick(t_py* x);
void py_run(t_py* x);
void py_edclose(t_py* x, char** text, long size);
long py_edsave(t_py* x, char** text, long size);
// void py_okclose(t_py* x, char *s, short *result);

</t>
<t tx="sta.20200602150733.1">/*--------------------------------------------------------------------------*/
// INCLUDES

/* max api */
#include "ext.h"
#include "ext_obex.h"

/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
</t>
<t tx="sta.20200602150814.1">/*--------------------------------------------------------------------------*/
// CONSTANTS

#define PY_MAX_ATOMS 128
#define PY_MAX_LOG_CHAR 500 // high number during development
#define PY_MAX_ERR_CHAR PY_MAX_LOG_CHAR

</t>
<t tx="sta.20200602151837.1">@path source/py/notes</t>
<t tx="sta.20200602164507.1">@path source/py/tests
</t>
<t tx="sta.20200602164529.1">/* python */

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;



@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602165143.1">/* --------------------------------------- */
// types

typedef struct _py {
    PyObject* p_globals;
} t_py;


#define PY_MAX_LONG 256
#define PY_MAX_FLOAT PY_MAX_LONG

/* --------------------------------------- */
// forward func declarations

int py_import(t_py* x, char* args);
// int py_eval(t_py* x, char* args);
int py_exec(t_py* x, char* args);
int py_execfile(t_py* x, char* args);
int py_run(t_py* x, char* args);

</t>
<t tx="sta.20200602165143.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* module = PyImport_AddModule("__main__"); // borrowed reference
    x-&gt;p_globals = PyModule_GetDict(module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argv[2]);
        // if (strcmp(argv[1], "eval") == 0)
        //     py_eval(x, argv[2]);
        if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argv[2]);
        if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argv[2]);
        if (strcmp(argv[1], "run") == 0)
            py_run(x, argv[2]);
    } else {
        printf("usage: test [import, eval, exec, execfile, run] args\n");
    }

    Py_FinalizeEx();
    return 0;
}


</t>
<t tx="sta.20200602165143.3">void handle_py_error(void)
{
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
}

</t>
<t tx="sta.20200602165143.4">int py_import(t_py* x, char* name)
{
    PyObject* x_module = NULL;

    if (name != NULL) {
        x_module = PyImport_ImportModule(name); // x_module borrrowed ref
        if (x_module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, name, x_module);
        return 0;
    }

error:
    handle_py_error();
    return -1;
}

</t>
<t tx="sta.20200602165143.5">int py_exec(t_py* x, char* statement)
{
    PyObject* pval = NULL;

    if (statement == NULL) {
        goto error;
    }

    pval = PyRun_String(statement, Py_single_input, x-&gt;p_globals,
                        x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}

</t>
<t tx="sta.20200602165143.6">int py_execfile(t_py* x, char* fpath)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (fpath == NULL) {
        goto error;
    }

    fhandle = fopen(fpath, "r");
    if (fhandle == NULL) {
        goto error;
    }

    pval = PyRun_File(fhandle, fpath, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);

    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


</t>
<t tx="sta.20200602165143.7">int py_run(t_py* x, char* fpath)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;
    int ret = 0;

    if (fpath == NULL) {
        goto error;
    }

    pval = Py_BuildValue("s", fpath); // new reference
    if (pval == NULL) {
        goto error;
    }

    fhandle = _Py_fopen_obj(pval, "r+");
    if (fhandle == NULL) {
        goto error;
    }

    ret = PyRun_SimpleFile(fhandle, fpath);
    if (ret == -1) {
        goto error;
    }

    // success
    fclose(fhandle);
    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


PyObject* py_eval_obj(t_py* x, char* expression)
{
    PyObject* pval = PyRun_String(expression, Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);
    if (pval != NULL) {
        return pval;
    } else {
        handle_py_error();
        return NULL;
    }
}


long py_eval_long(t_py* x, char* expression)
{

    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyLong_Check(pval)) {
        goto error;
    }

    long result = PyLong_AsLong(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


double py_eval_double(t_py* x, char* expression)
{

    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyFloat_Check(pval)) {
        goto error;
    }

    double result = PyFloat_AsDouble(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


</t>
<t tx="sta.20200602165143.8">const char* py_eval_unicode(t_py* x, char* expression)
{
    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyUnicode_Check(pval)) {
        goto error;
    }

    const char* result = PyUnicode_AsUTF8(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return NULL;
}

// caller must free
</t>
<t tx="sta.20200602165143.9">float* py_eval_float_seq(t_py* x, char* expression)
{
    // caller must free
    float *result;
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    PyObject* pval = py_eval_obj(x, expression);
    if (pval == NULL) {
        goto error;
    }

    if (!PySequence_Check(pval)) {
        goto error;
    }

    Py_ssize_t length = PySequence_Length(pval);
    if (length == -1) {
        goto error;
    }

    // use calloc instead of malloc to init zeros
    result = (float*)calloc(length, sizeof(float));
    if (result == NULL) {
        goto error;
    }

    if ((iter = PyObject_GetIter(pval)) != NULL) {
        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyFloat_Check(item)) {
                if (PyFloat_AsDouble(item) != -1) {
                    result[i] = (float)PyFloat_AsDouble(item);
                    i++;              
                }    
            }
            Py_DECREF(item);
        }
    }

    // success
    Py_XDECREF(pval);
    return result; // caller must free

    error:
        handle_py_error();
        Py_XDECREF(pval);
        return NULL;
}
// caller must free
</t>
<t tx="sta.20200602165301.1">long* py_eval_long_seq(t_py* x, char* expression)
{
    // caller must free
    long *result;
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    PyObject* pval = py_eval_obj(x, expression);
    if (pval == NULL) {
        goto error;
    }

    if (!PySequence_Check(pval)) {
        goto error;
     }

    Py_ssize_t length = PySequence_Length(pval);
    if (length == -1) {
        goto error;
    }

    // use calloc instead of malloc to init zeros
    result = (long*)calloc(length, sizeof(long));
    if (result == NULL) {
        goto error;
    }

    if ((iter = PyObject_GetIter(pval)) != NULL) {
        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                if (PyLong_AsLong(item) != -1) {
                    result[i] = PyLong_AsLong(item);
                    i++;              
                }    
            }
            Py_DECREF(item);
        }
    }

    // success
    Py_XDECREF(pval);
    return result; // caller must free

    error:
        handle_py_error();
        Py_XDECREF(pval);
        return NULL;
}

// caller must free
</t>
<t tx="sta.20200602165801.1">@language rest
@wrap

This @settings tree contains all active settings.

Settings outside this tree have no effect.

The node "Qt Gui Stylesheet settings" contains most of the setting relating to appearance.
</t>
<t tx="sta.20200602165801.470">@language rest
@wrap

</t>
<t tx="sta.20200602165801.471">If True, names uses headline "Foo.bar" for bar() defined in class
Foo, and headline "bar (foo.py)" for bar() defined at top level in
foo.py.  This is useful if you've cloned the node so its origin is
not obvious from context.

If False, does not do the above, useful if you don't use clones
and don't want the visual clutter of repeated class / file names.</t>
<t tx="sta.20200602165810.1">@doc

This is a leo project file used capture notes and to restructure the project with relative ease.

It is not necessary to use this to build or develop in the project.

@</t>
<t tx="sta.20200602170210.1">
/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;


@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170222.1">/* --------------------------------------- */
// types

typedef struct _py {
    PyObject* p_globals;
} t_py;


typedef enum _bool {
    false,
    true
} bool;

/* --------------------------------------- */
// forward func declarations

void py_import(t_py* x, char* args);
void py_eval(t_py* x, char* args);
void py_exec(t_py* x, char* args);
void py_execfile(t_py* x, char* args);
void py_run(t_py* x, char* args);
void py_pipe(t_py* x, char* args);

</t>
<t tx="sta.20200602170222.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* main_module = PyImport_AddModule("__main__"); // borrowed reference
    x-&gt;p_globals = PyModule_GetDict(main_module); // borrowed reference
    int err = PyDict_SetItemString(x-&gt;p_globals, "__builtins__", PyEval_GetBuiltins());
    if (err == -1)
        return err;



    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argv[2]);
        if (strcmp(argv[1], "eval") == 0)
            py_eval(x, argv[2]);
        if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argv[2]);
        if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argv[2]);
        if (strcmp(argv[1], "run") == 0)
            py_run(x, argv[2]);
        if (strcmp(argv[1], "pipe") == 0)
            py_pipe(x, argv[2]);
    } else {
        printf("usage: test [import, eval, exec, execfile, run, pipe] args\n");
    }

    Py_FinalizeEx();
    return 0;
}

void py_handle_error(void)
{
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
}

static void print(PyObject *o)
{
    PyObject_Print(o, stdout, Py_PRINT_RAW);
    printf("\n");
}

// static void print_repr(PyObject *o)
// {
//     PyObject_Print(o, stdout, 0);
// }

void py_handle_float_output(t_py* x, PyObject* pfloat, bool free_now)
{
    if (pfloat == NULL) {
        goto error;
    }

    if (PyFloat_Check(pfloat)) {
        float float_result = (float)PyFloat_AsDouble(pfloat);
        if (float_result == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }

        printf("float: %f\n", float_result);
    }

    if (free_now) {
        Py_XDECREF(pfloat);
    }
    return;

error:
    py_handle_error();
    Py_XDECREF(pfloat);
}


void py_handle_long_output(t_py* x, PyObject* plong, bool free_now)
{
    if (plong == NULL) {
        goto error;
    }

    if (PyLong_Check(plong)) {
        long long_result = PyLong_AsLong(plong);
        if (long_result == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        printf("long: %ld\n", long_result);
    }

    if (free_now) {
        Py_XDECREF(plong);
    }
    return;

error:
    py_handle_error();
    Py_XDECREF(plong);
}


void py_handle_string_output(t_py* x, PyObject* pstring, bool free_now)
{
    char buffer[100];

    if (pstring == NULL) {
        goto error;
    }

    if (PyUnicode_Check(pstring)) {
        const char* unicode_result = PyUnicode_AsUTF8(pstring);
        if (unicode_result == NULL) {
            goto error;
        }
        strcpy(buffer, unicode_result);
        printf("unicode: %s\n", buffer);
    }

    if (free_now) {
        Py_XDECREF(pstring);
    }
    return;

error:
    py_handle_error();
    Py_XDECREF(pstring);
}


void py_handle_list_output(t_py* x, PyObject* plist, bool free_now)
{
    if (plist == NULL) {
        goto error;
    }

    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            printf("cannot convert py list of length 0 to atoms");
            goto error;
        }

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                printf("%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                printf("%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                printf("%d unicode: %s\n", i, unicode_item);
                i++;
            }
            Py_DECREF(item);
        }

    }

    if (free_now) {
        Py_XDECREF(plist);
    }
    return;

error:
    py_handle_error();
    Py_XDECREF(plist);

}


void py_handle_output(t_py* x, PyObject* pval)
{
    py_handle_float_output(x, pval, 0);
    py_handle_long_output(x, pval, 0);
    py_handle_string_output(x, pval, 0);
    py_handle_list_output(x, pval, 0);

    // final cleanup
    Py_XDECREF(pval);
    return;
}

//--------------------------------------------------------------------------

</t>
<t tx="sta.20200602170222.3">void py_import(t_py* x, char* args)
{
    PyObject* x_module = NULL;

    if (args != NULL) {
        x_module = PyImport_ImportModule(args); // x_module borrrowed ref
        if (x_module == NULL) {
            PyErr_SetString(PyExc_ImportError, "Ooops again.");
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, args, x_module);
        printf("imported: %s\n", args);
    }
    // else goto error;

error:
    py_handle_error();
}


</t>
<t tx="sta.20200602170222.4">void py_run(t_py* x, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;
    int ret = 0;

    if (args == NULL) {
        printf("%s: could not retrieve args\n", args);
        goto error;
    }

    pval = Py_BuildValue("s", args); // new reference
    if (pval == NULL) {
        goto error;
    }

    fhandle = _Py_fopen_obj(pval, "r+");
    if (fhandle == NULL) {
        printf("could not open file '%s'\n", args);
        goto error;
    }

    ret = PyRun_SimpleFile(fhandle, args);
    if (ret == -1) {
        goto error;
    }

    // success
    fclose(fhandle);
    Py_DECREF(pval);

error:
    py_handle_error();
    Py_XDECREF(pval);
}


</t>
<t tx="sta.20200602170222.5">void py_execfile(t_py* x, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (args == NULL) {
        printf("execfile: could not retrieve arg: %s\n", args);
        goto error;
    }

    fhandle = fopen(args, "r");
    if (fhandle == NULL) {
        printf("could not open file '%s'\n", args);
        goto error;
    }

    pval = PyRun_File(fhandle, args, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);

error:
    py_handle_error();
    Py_XDECREF(pval);
}


</t>
<t tx="sta.20200602170222.6">void py_exec(t_py* x, char* args)
{
    PyObject* pval = NULL;

    if (args == NULL) {
        printf("exec: could not retrieve args: %s\n", args);
        goto error;
    }

    pval = PyRun_String(args, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);

error:
    py_handle_error();
    Py_XDECREF(pval);
}


</t>
<t tx="sta.20200602170222.7">void py_eval(t_py* x, char* args)
{
    PyObject* pval = NULL;
    PyObject* locals = NULL;

    if (args == NULL) {
        printf("eval: could not retrieve quoted args: %s\n", args);
        goto error;
    }

    locals = PyDict_New();
    if (locals == NULL) {
        goto error;
    }

    pval = PyRun_String(args, Py_eval_input, x-&gt;p_globals, locals);
    if (pval == NULL) {
        goto error;
    }

    py_handle_output(x, pval);
    return;

error:
    py_handle_error();
    Py_XDECREF(pval);
}




void py_pipe(t_py* x, char* args)
{
    PyObject* pargstr = NULL;
    PyObject* pstr = NULL;
    PyObject* list = NULL;
    PyObject* item = NULL;
    PyObject* funcs = NULL;
    PyObject* funcs_iter = NULL;
    PyObject* func = NULL;
    PyObject* pval = NULL;

    printf("args: %s\n", args);


    pargstr = PyUnicode_FromString(args);
    if (pargstr == NULL) {
        printf("could not convert cstring to py unicode string\n");
        goto error;
    }

    list = PyUnicode_Split(pargstr, NULL, -1);
    if (list == NULL) {
        printf("could not not split py unicode string into py list\n");
        goto error;
    }

    Py_ssize_t argc = PyList_Size(list);
    printf("argc: %ld\n", argc);

    if (argc &lt; 2) {
        printf("pipe needs at least two arguments.\n");
        goto error;
    }

    pstr = PyList_GetItem(list, 0);
    print(pstr);
    // print_repr(pstr);
    if (pstr == NULL) {
        printf("could not retrieve input value\n");
        goto error;
    }

    pval = PyNumber_Long(pstr);
    if (pval == NULL) {
        printf("input value is not a int\n");
        pval = PyNumber_Float(pstr);
        if (pval == NULL) {
            printf("input value is a string\n");
            pval = pstr;
        } else {
            printf("input value is a float\n");
        }
    } else {
        printf("input value is an int\n");
    }

    funcs = PyList_GetSlice(list, 1, argc);
    print(funcs);
    if (funcs == NULL || !PyList_Check(funcs)) {
        printf("could not retrieve function names\n");
        goto error;
    }
    funcs_iter = PyObject_GetIter(funcs);
    if (funcs_iter == NULL) {
        goto error;
    }

    PyObject* builtins = PyDict_GetItemString(x-&gt;p_globals, "__builtins__");

    while ((item = PyIter_Next(funcs_iter)) != NULL) {
        print(item);

        func = PyDict_GetItemWithError(x-&gt;p_globals, item);
        if (func == NULL) {
            printf("could not retrieve callable name from globals dicts\n");
            printf("trying to get from builtins\n");
            if (PyDict_Contains(builtins, item)) {
                func = PyDict_GetItemWithError(builtins, item);
            }
            else {
                printf("not a builtin nor in globals\n");
                goto error;
            }
        }
        if (func == NULL) {
            printf("unable to to retrieve func without error\n");
            goto error;
        }

        print(func);

        if (!PyCallable_Check(func)) {
            printf("object retrieved is not a callable\n");
            goto error;
        }

        pval = PyObject_CallFunctionObjArgs(func, pval, NULL);
        if (pval == NULL) {
            printf("error occurred returning output from func\n");
            goto error;
        }
        Py_DECREF(func);
        Py_DECREF(item);
    }
    Py_XDECREF(funcs_iter);

    if (pval != NULL) {
        py_handle_output(x, pval);
        Py_XDECREF(list);
        Py_XDECREF(funcs);
        Py_XDECREF(pstr);
        Py_XDECREF(pval);
        return;
    }

error:
    py_handle_error();
    Py_XDECREF(list);
    Py_XDECREF(funcs);
    Py_XDECREF(pstr);
    Py_XDECREF(pval);
}


void py_pipe2(t_py* x, char* args)
{
    PyObject* pipe_co = NULL;
    PyObject* pipe_fun = NULL;    
    PyObject* pval = NULL;
    PyObject* p_str = NULL;

    pipe_co = PyRun_String(
        "def pipe(arg):\n"
            "\targs = arg.split()\n"
            "\tval = eval(args[0])\n"
            "\tfuncs = [eval(f) for f in args[1:]]\n"
            "\tfor f in funcs:\n"
                "\t\tval = f(val)\n"
            "\treturn val\n",
            Py_single_input, x-&gt;p_globals, x-&gt;p_globals);

    if (pipe_co == NULL) {
        printf("pipe func is NULL");
        goto error;
    }

    p_str = PyUnicode_FromString(args);
    if (p_str == NULL) {
        printf("cstr -&gt; pyunicode conversion failed");
        goto error;
    }

    pipe_fun = PyDict_GetItemString(x-&gt;p_globals, "pipe");
    if (pipe_fun == NULL) {
        printf("retrieving pipe func from globals failed");
        goto error;
    }

    pval = PyObject_CallFunctionObjArgs(pipe_fun, p_str, NULL);

    if (pval != NULL) {
        py_handle_output(x, pval);
        Py_XDECREF(pipe_co);
        Py_XDECREF(p_str);
        // Py_XDECREF(pipe_fun);
        Py_XDECREF(pval);

        return;
    } else {
        goto error;
    }

error:
    py_handle_error();
    Py_XDECREF(pipe_co);
    Py_XDECREF(p_str);
    // Py_XDECREF(pipe_fun);
    Py_XDECREF(pval);
}
</t>
<t tx="sta.20200602170456.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170513.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170550.1">int main(int argc, char* argv[])
{
    PyObject *pName, *pModule, *pFunc;
    PyObject *pArgs, *pValue;
    int i;

    if (argc &lt; 3) {
        fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
        return 1;
    }

    Py_Initialize();
    pName = PyUnicode_DecodeFSDefault(argv[1]);
    /* Error checking of pName left out */

    pModule = PyImport_Import(pName);
    Py_DECREF(pName);

    if (pModule != NULL) {
        pFunc = PyObject_GetAttrString(pModule, argv[2]);
        /* pFunc is a new reference */

        if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {
            pArgs = PyTuple_New(argc - 3);
            for (i = 0; i &lt; argc - 3; ++i) {
                pValue = PyLong_FromLong(atoi(argv[i + 3]));
                if (!pValue) {
                    Py_DECREF(pArgs);
                    Py_DECREF(pModule);
                    fprintf(stderr, "Cannot convert argument\n");
                    return 1;
                }
                /* pValue reference stolen here: */
                PyTuple_SetItem(pArgs, i, pValue);
            }
            pValue = PyObject_CallObject(pFunc, pArgs);
            Py_DECREF(pArgs);
            if (pValue != NULL) {
                printf("Result of call: %ld\n", PyLong_AsLong(pValue));
                Py_DECREF(pValue);
            } else {
                Py_DECREF(pFunc);
                Py_DECREF(pModule);
                PyErr_Print();
                fprintf(stderr, "Call failed\n");
                return 1;
            }
        } else {
            if (PyErr_Occurred())
                PyErr_Print();
            fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
        }
        Py_XDECREF(pFunc);
        Py_DECREF(pModule);
    } else {
        PyErr_Print();
        fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
        return 1;
    }
    if (Py_FinalizeEx() &lt; 0) {
        return 120;
    }
    return 0;
}
</t>
<t tx="sta.20200602170556.1">int main(int argc, char *argv[]) {
    (void)argc;
    wchar_t *program = Py_DecodeLocale(argv[0], NULL);
    if (program == NULL) {
        fprintf(stderr, "Fatal error: cannot decode argv[0]\n");
        exit(1);
    }
    Py_SetProgramName(program);
    Py_Initialize();
    PyRun_SimpleString(argv[1]);
    if (Py_FinalizeEx() &lt; 0) {
        exit(120);
    }
    PyMem_RawFree(program);
    return 0;
}
</t>
<t tx="sta.20200603072826.1">long py_scan_callback(t_py* x, t_object* box)
{
    t_rect jr;
    t_object* p;
    t_symbol* s;
    t_symbol* varname;
    t_object* obj;
    t_symbol* obj_id;

    jbox_get_patching_rect(box, &amp;jr);
    p = jbox_get_patcher(box);
    varname = jbox_get_varname(box);
    obj = jbox_get_object(box);

    // STRANGE BUG: single quotes in py_log cause a crash but not with post!!
    // perhaps because post is a macro for object_post?
    if (varname &amp;&amp; varname != gensym("")) {
        // post("XXXX -&gt; '%s'", varname-&gt;s_name);
        py_log(x, "storing object %s in the global registry", varname-&gt;s_name);
        hashtab_store(py_global_registry, varname, obj);
    }

    obj_id = jbox_get_id(box);
    s = jpatcher_get_name(p);
    object_post(
        (t_object*)x,
        "in patcher:%s, varname:%s id:%s box @ x %ld y %ld, w %ld, h %ld",
        s-&gt;s_name, varname-&gt;s_name, obj_id-&gt;s_name, (long)jr.x, (long)jr.y,
        (long)jr.width, (long)jr.height);
    return 0;
}


</t>
<t tx="sta.20200605120205.1">void py_locatefile(t_py* x, char* filename)
{
    // works for folders as well
    char name[MAX_FILENAME_CHARS];
    short path;
    t_fourcc type;

    char pathname[MAX_PATH_CHARS];
    short err;

    if (filename == NULL)
        return;

    strncpy_zero(name, filename, MAX_FILENAME_CHARS);

    if (locatefile_extended(name, &amp;path, &amp;type, NULL, 0)) {
        error("path %s not found", name);
    } else {
        post("path %s, path %d", name, path);
        err = path_topathname(path, name, pathname);
        if (err == 0) {
            post("absolute path: %s", pathname);
        }
    }
}

</t>
<t tx="sta.20200605120324.1">void py_code(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* co = NULL;
    PyObject* pval = NULL;
    t_max_err err;
    int is_eval = 1;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "call %s", text);
    } else {
        goto error;
    }

    co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_eval_input);

    if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
        PyErr_Clear();
        co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_single_input);
        is_eval = 0;
    }

    if (co == NULL) { // can be eval-co or exec-co or NULL here
        goto error;
    }
    sysmem_freeptr(text);

    pval = PyEval_EvalCode(co, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    Py_DECREF(co);

    if (!is_eval) {
        // bang for exec-type op
        outlet_bang(x-&gt;p_outlet_right);
    } else {
        py_handle_output(x, pval);
    }
    return;

error:
    py_handle_error(x, "call failed");
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}


void py_anything(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    t_atom atoms[PY_MAX_ATOMS];
    long textsize = 0;
    char* text = NULL;
    PyObject* co = NULL;
    PyObject* pval = NULL;
    t_max_err err;
    int is_eval = 1;

    if (s == gensym("")) {
        return;
    }

    // set '=' as shorthand for assign method
    if (s == gensym("=")) {
        py_assign(x, gensym(""), argc, argv);
        return;
    }

    // set symbol as first atom in new atoms array
    atom_setsym(atoms, s);

    for (int i = 0; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            atom_setfloat((atoms + (i + 1)), atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            atom_setlong((atoms + (i + 1)), atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            atom_setsym((atoms + (i + 1)), atom_getsym(argv + i));
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    err = atom_gettext(argc + 1, atoms, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "&gt;&gt;&gt; %s", text);
    } else {
        goto error;
    }

    co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_eval_input);

    if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
        PyErr_Clear();
        co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_single_input);
        is_eval = 0;
    }

    if (co == NULL) { // can be eval-co or exec-co or NULL here
        goto error;
    }
    sysmem_freeptr(text);

    pval = PyEval_EvalCode(co, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    Py_DECREF(co);

    if (!is_eval) {
        // bang for exec-type op
        outlet_bang(x-&gt;p_outlet_right);
    } else {
        py_handle_output(x, pval);
    }
    return;

error:
    py_handle_error(x, "anything failed");
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200606044751.1">void py_handle_output(t_py* x, PyObject* pval)
{
    if (pval == NULL) {
        py_error(x, "cannot handle NULL value");
        return;
    }

    if (PyFloat_Check(pval)) {
        py_handle_float_output(x, pval);
        return;
    }

    else if (PyLong_Check(pval)) {
        py_handle_long_output(x, pval);
        return;
    }

    else if (PyUnicode_Check(pval)) {
        py_handle_string_output(x, pval);
        return;
    }

    else if (PySequence_Check(pval) &amp;&amp; !PyBytes_Check(pval)
             &amp;&amp; !PyByteArray_Check(pval)) {
        py_handle_list_output(x, pval);
        return;
    }

    else if (PyDict_Check(pval)) {
        py_handle_dict_output(x, pval);
        return;
    }

    else if (pval == Py_None) {
        return;
    }

    else {
        py_error(x, "cannot handle his type of value");
        return;
    }
}

</t>
<t tx="sta.20200606073716.1">/*--------------------------------------------------------------------------*/
// INTEROBJECT

</t>
<t tx="sta.20200607084251.1">void py_eval2(t_py* x, t_symbol* s, long argc, t_atom* argv)
{

    long textsize = 0;
    char* text = NULL;
    PyObject* pval = NULL;
    t_max_err err;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    // OBEX_UTIL_ATOM_GETTEXT_SYM_NO_QUOTE);

    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "eval %s", text);
    } else {
        goto error;
    }

    pval = PyRun_String(text, Py_eval_input, x-&gt;p_globals, x-&gt;p_globals);

    if (pval == NULL) {
        sysmem_freeptr(text);
        goto error;
    }

    // success
    sysmem_freeptr(text);
    py_handle_output(x, pval);
    return;

error:
    py_handle_error(x, "eval failure");
}

</t>
<t tx="sta.20200607084300.1">void py_exec2(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* pval = NULL;
    t_max_err err;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "exec %s", text);
    } else {
        goto error;
    }

    pval = PyRun_String(text, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        sysmem_freeptr(text);
        goto error;
    }

    // success cleanup
    sysmem_freeptr(text);
    Py_DECREF(pval);
    // success bang
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "exec failed");
    Py_XDECREF(pval);
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200608031546.1">
@language python</t>
<t tx="sta.20200608031559.1">from os import listdir
from fnmatch import fnmatch
from os.path import join, abspath, basename, normpath, isfile, isdir, splitext

DEFAULT_IGNORE = ['*.pyc', '*.leo', '*.gif', '*.png', '*.jpg', '*.json']
DEFAULT_PARSE = { 'py':'clean', 'txt':'auto', 'css':'auto', 'html':'auto'}


class LeoDirectory(object):
    def __init__(self, path, to_parse=DEFAULT_PARSE, to_ignore=DEFAULT_IGNORE,
            relative_paths=True, sort=True):
        self.path = path
        self.to_parse = to_parse
        self.to_ignore = to_ignore
        self.relative_paths = relative_paths
        self.sort = sort
        assert isdir(path), "%s is not a directory" % path

    def match_to_ignore(self, string):
        return any(fnmatch(string, p) for p in self.to_ignore)

    def is_ignorable(self, string):
        return any([string.startswith('.'), self.match_to_ignore(string)])

    def parse(self, path):
        name, ext = splitext(path)
        ext = ext[1:]
        return name, ext

    def is_parsable(self, path):
        if isfile(path):
            name, ext = self.parse(path)
            if ext in self.to_parse:
                return True
        if isdir(path):
            # is directory can pass
            g.es('---&gt; '+ path)
            return True

        return False

    def headline_from_path(self, path):
        filename = basename(path)
        name, ext = self.parse(path)
        nodetype = self.to_parse[ext] if (ext in self.to_parse) else 'asis'
        return "@%s %s" % (nodetype, filename)

    def body_from_path(self, path):
        body = "@path %s" % normpath(path)
        return body

    def leo_from_directory(self, directory, parent=None, isroot=True, sort=True):
        if not self.relative_paths: directory = abspath(directory)
        if isroot:
            body = self.body_from_path(directory)
            c.setBodyString(p, body)

        dirlist = sorted(listdir(directory)) if sort else listdir(directory)
        for name in dirlist:
            if self.is_ignorable(name):
                g.es("ignore: "+name)
                continue
            path = join(directory, name)
            if isfile(path):
                g.es('file:', path)
                headline = self.headline_from_path(path)
                if parent:
                    node = parent
                else:
                    node = p
                child = node.insertAsLastChild()
                child.initHeadString(headline)
            else:
                g.es('dir:', path)
                headline = basename(path)
                body = self.body_from_path(path)
                if parent:
                    node = parent
                else:
                    node = p
                child = node.insertAsLastChild()
                child.initHeadString(headline)
                child.initBodyString(body)
                self.leo_from_directory(path, parent=child, isroot=False)

    def render(self):
        try:
            self.leo_from_directory(self.path, sort=self.sort)
        finally:
            c.redraw()

LeoDirectory('.').render()</t>
<t tx="sta.20200608031946.1"></t>
<t tx="sta.20200608042323.1">/*--------------------------------------------------------------------------*/
// COMMON HANDLERS

</t>
<t tx="sta.20200608043930.1">void py_lookup(t_py* x, t_symbol* s)
{
    t_object* obj = NULL;
    t_max_err err = NULL;

    if (hashtab_getsize(py_global_registry) == 0) {
        py_error(x, "registry not populated");
        return;
    }

    err = hashtab_lookup(py_global_registry, s, &amp;obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found with name %s", s-&gt;s_name);
    } else {
        py_log(x, "found object: %s", s-&gt;s_name);
    }
    return;
}

</t>
<t tx="sta.20200610070057.1">
void py_send_from_seq(t_py* x, PyObject* seq)
{

    if (seq == NULL) {
        goto error;
    }

    if (!PySequence_Check(seq) || PyUnicode_Check(seq) || PyBytes_Check(seq)
        || PyByteArray_Check(seq)) {
        goto error;
    }

    // list -&gt; t_atom vars
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    t_atom atoms_static[PY_MAX_ATOMS];
    t_atom* atoms = NULL;
    int is_dynamic = 0;

    Py_ssize_t seq_size = PySequence_Length(seq);
    long argc = (long)seq_size;

    if (seq_size &lt; 2) {
        py_error(x, "cannot convert py sequence length &lt; 2 to atoms");
        goto error;
    }

    if (seq_size &gt; PY_MAX_ATOMS) {
        py_log(x, "dynamically increasing size of atom array");
        atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS, seq_size + 1);
        is_dynamic = 1;

    } else {
        atoms = atoms_static;
    }

    if ((iter = PyObject_GetIter(seq)) == NULL) {
        goto error;
    }

    while ((item = PyIter_Next(iter)) != NULL) {
        if (PyLong_Check(item)) {
            long long_item = PyLong_AsLong(item);
            atom_setlong(atoms + i, long_item);
            py_log(x, "%d long: %ld\n", i, long_item);
            i++;
        }

        if PyFloat_Check (item) {
            float float_item = PyFloat_AsDouble(item);
            atom_setfloat(atoms + i, float_item);
            py_log(x, "%d float: %f\n", i, float_item);
            i++;
        }

        if PyUnicode_Check (item) {
            const char* unicode_item = PyUnicode_AsUTF8(item);
            py_log(x, "%d unicode: %s\n", i, unicode_item);
            atom_setsym(atoms + i, gensym(unicode_item));
            i++;
        }
        Py_DECREF(item);
    }

    // send vars
    t_object* obj = NULL;
    char* obj_name = NULL;
    t_symbol* msg_sym = NULL;
    t_max_err err = NULL;

    if ((atoms + 0)-&gt;a_type != A_SYM) {
        py_error(
            x, "1st arg of send needs to be a symbol name of receiver object");
        goto error;
    }

    // argv+0 is the object name to send to
    obj_name = atom_getsym(atoms)-&gt;s_name;
    if (obj_name == NULL) {
        goto error;
    }

    // if registry is empty, scan it
    if (hashtab_getsize(py_global_registry) == 0) {
        py_scan(x);
    }

    // // lookup name in registry
    err = hashtab_lookup(py_global_registry, gensym(obj_name), &amp;obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found in the registry");
        goto error;
    }

    // atom after the name of the receiver
    switch ((atoms + 1)-&gt;a_type) {
    case A_SYM: {
        msg_sym = atom_getsym(atoms + 1);
        if (msg_sym == NULL) { // should check type here
            goto error;
        }
        // address the minimum case: e.g a bang
        if (argc - 2 == 0) { //
            argc = 0;
            atoms = NULL;
        } else {
            argc = argc - 2;
            atoms = atoms + 2;
        }
        break;
    }
    case A_FLOAT: {
        msg_sym = gensym("float");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        atoms = atoms + 1;

        break;
    }
    case A_LONG: {
        msg_sym = gensym("int");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        atoms = atoms + 1;

        break;
    }
    default:
        py_log(x, "cannot process unknown type");
        break;
    }

    // methods to get method type
    t_messlist* messlist = object_mess((t_object*)obj, msg_sym);
    if (messlist) {
        post("messlist-&gt;m_sym  (name of msg): %s", messlist-&gt;m_sym-&gt;s_name);
        post("messlist-&gt;m_type (type of msg): %d", messlist-&gt;m_type[0]);
    }

    err = object_method_typed(obj, msg_sym, argc, atoms, NULL);
    if (err) {
        py_error(x, "failed to send a message to object %s", obj_name);
        goto error;
    }

    // process here
    outlet_bang(x-&gt;p_outlet_right);
    py_log(x, "end iter op: %d", i);

    if (is_dynamic) {
        py_log(x, "restoring to static atom array");
        atom_dynamic_end(atoms_static, atoms);
    }

    // final cleanup
    Py_XDECREF(seq);
    return;

error:
    py_error(x, "send failed");
    return;
}
</t>
<t tx="sta.20200610100158.1">PyObject* py_atoms_to_list(t_py* x, long argc, t_atom* argv, int start_from)
{

    PyObject* plist = NULL; // python list

    if ((plist = PyList_New(0)) == NULL) {
        py_error(x, "could not create an empty python list");
        goto error;
    }

    for (int i = start_from; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                goto error;
            }
            PyList_Append(plist, p_float);
            Py_DECREF(p_float);
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                goto error;
            }
            PyList_Append(plist, p_long);
            Py_DECREF(p_long);
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                goto error;
            }
            PyList_Append(plist, p_str);
            Py_DECREF(p_str);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }
    return plist;

error:
    py_error(x, "atom to list conversion failed");
    return NULL;
}

</t>
<t tx="sta.20200610100240.1">/*--------------------------------------------------------------------------*/
// TRANSLATORS

</t>
<t tx="sta.20200610104609.1">void py_handle_long_output(t_py* x, PyObject* plong)
{
    if (plong == NULL) {
        goto error;
    }

    if (PyLong_Check(plong)) {
        long long_result = PyLong_AsLong(plong);
        if (long_result == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        outlet_int(x-&gt;p_outlet_left, long_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    Py_XDECREF(plong);
    return;

error:
    py_handle_error(x, "py_handle_long_output failed");
    Py_XDECREF(plong);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200610104706.1">
void py_handle_list_output(t_py* x, PyObject* plist, bool free_now)
{
    Py_ssize_t seq_size = PySequence_Length(plist);

    long argc = (long)seq_size;
    t_atom* argv = py_list_to_atom(x, plist);

    outlet_list(x-&gt;p_outlet_left, NULL, argc, argv);
    outlet_bang(x-&gt;p_outlet_right);
    
    free atoms
    for (int i=0; i &lt; argc; i++) {
        sysmem_freeptr((argv+i));
    }
    sysmem_freeptr(argv);

    if (free_now) {
        Py_XDECREF(plist);
    }
    return;
}
</t>
<t tx="sta.20200610105537.1">void py_handle_string_output(t_py* x, PyObject* pstring)
{
    if (pstring == NULL) {
        goto error;
    }

    if (PyUnicode_Check(pstring)) {
        const char* unicode_result = PyUnicode_AsUTF8(pstring);
        if (unicode_result == NULL) {
            goto error;
        }
        outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
        outlet_bang(x-&gt;p_outlet_right);
    }

    Py_XDECREF(pstring);
    return;

error:
    py_handle_error(x, "py_handle_string_output failed");
    Py_XDECREF(pstring);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200610164212.1">
void py_list_to_atom2(t_py* x, PyObject* plist, long* argc, t_atom** argv)
{
    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            py_error(x, "cannot convert py sequence of length 0 to atoms");
            goto error;
        }

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                atom_setlong(*argv + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                atom_setfloat(*argv + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(*argv + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }
        Py_XDECREF(plist);
        return;
    }

error:
    py_handle_error(x, "atom to list conversion failed");
    Py_XDECREF(plist);
}
</t>
<t tx="sta.20200610181828.1">void py_handle_float_output(t_py* x, PyObject* pfloat)
{
    if (pfloat == NULL) {
        goto error;
    }

    if (PyFloat_Check(pfloat)) {
        float float_result = (float)PyFloat_AsDouble(pfloat);
        if (float_result == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }

        outlet_float(x-&gt;p_outlet_left, float_result);
        outlet_bang(x-&gt;p_outlet_right);
    }
    Py_XDECREF(pfloat);
    return;

error:
    py_handle_error(x, "py_handle_float_output failed");
    Py_XDECREF(pfloat);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200610222640.1">t_atom* py_list_to_atom(t_py* x, PyObject* plist)
{
    if (plist == NULL) {
        goto error;
    }

    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;
        
        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            py_error(x, "cannot convert py list of length 0 to atoms");
            goto error;
        }
        
        long argc = (long)seq_size;
        t_atom* atoms = (t_atom *)sysmem_newptr(sizeof(t_atom *) * argc);
        // free with sysmem_freeptr(atoms)

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check(item) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check(item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }
        Py_XDECREF(plist);
        return atoms;
    }

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(plist);
    return NULL;
}

</t>
<t tx="sta.20200610231913.1">void py_handle_list_output(t_py* x, PyObject* plist)
{
    if (plist == NULL) {
        goto error;
    }

    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(plist);
        py_log(x, "seq_size: %d", seq_size);

        if (seq_size == 0) {
            py_error(x, "cannot convert py list of length 0 to atoms");
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }
        py_log(x, "seq_size2: %d", seq_size);

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if (PyFloat_Check(item)) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            // if (PyNumber_Check(item)) {
            //     float float_item = PyFloat_AsDouble(item);
            //     if (float_item == -1.0) {
            //         if (PyErr_Occurred())
            //             goto error;
            //     }
            //     atom_setfloat(atoms + i, float_item);
            //     py_log(x, "%d float: %f\n", i, float_item);
            //     i++;
            // }

            if (PyUnicode_Check(item)) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                atom_setsym(atoms + i, gensym(unicode_item));
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                i++;
            }
            Py_DECREF(item);
        }

        outlet_list(x-&gt;p_outlet_left, NULL, i, atoms);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }

    Py_XDECREF(plist);
    return;

error:
    py_handle_error(x, "py_handle_list_output failed");
    Py_XDECREF(plist);
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200611235620.1">t_hashtab* get_global_registry(void) { return py_global_registry; }





</t>
<t tx="sta.20200612043307.1"></t>
<t tx="sta.20200612044656.1">@language c

@doc

This section includes code that is workging and not working that is redundant, or perhaps not required now, or that merely served, at some point, to test or illustrate something.

There is no requirement to 'graduate' code from here. 

@</t>
<t tx="sta.20200612044825.1"></t>
<t tx="sta.20200612044941.1">cdef send2(self, str name, list args):
    _args = [name] + args
    px.py_send_from_seq(self.obj, &lt;PyObject*&gt;_args)
</t>
<t tx="sta.20200612045044.1">@language cython


</t>
<t tx="sta.20200612045651.1">/*--------------------------------------------------------------------------*/
// METHODS

/* common handlers */
void py_handle_float_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_long_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_string_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_list_output(t_py* x, PyObject* pval, bool free_now);

/* core python methods */
void py_eval2(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_exec2(t_py* x, t_symbol* s, long argc, t_atom* argv);

/* extra python methods */
void py_code(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_globex(t_py* x, long n);

/* informational */

/* testing */

/* interobject communications */
void py_lookup(t_py* x, t_symbol* s);

/* code editor */
void py_locatefile(t_py* x, char* filename);

// helpers for api
void py_send_from_seq(t_py* x, PyObject* seq);
t_atom* py_list_to_atom(t_py* x, PyObject* plist);
void py_list_to_atom2(t_py* x, PyObject* plist, long* argc, t_atom** argv);
</t>
<t tx="sta.20200612051513.1">void py_handle_output(t_py* x, PyObject* pval)
{

    // handle ints and longs
    if (PyLong_Check(plong)) {
        long long_result = PyLong_AsLong(plong);
        if (long_result == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        outlet_int(x-&gt;p_outlet_left, long_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    // handle floats and doubles
    if (PyFloat_Check(pfloat)) {
        float float_result = (float)PyFloat_AsDouble(pfloat);
        if (float_result == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }
        outlet_float(x-&gt;p_outlet_left, float_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    // handle strings
    if (PyUnicode_Check(pstring)) {
        const char* unicode_result = PyUnicode_AsUTF8(pstring);
        if (unicode_result == NULL) {
            goto error;
        }
        outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
        outlet_bang(x-&gt;p_outlet_right);
    }

    /* handle any sequence except strings, and presently
       bytes and byte arrays (until there is a reason to)
    */
    if (PySequence_Check(pval) &amp;&amp; !PyUnicode_Check(pval)
        &amp;&amp; !PyBytes_Check(pval) &amp;&amp; !PyByteArray_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);

        if (seq_size &lt;= 0) {
            py_error(
                x, "cannot convert python sequence with length &lt;= 0 to atoms");
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check(item) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check(item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }

        outlet_list(x-&gt;p_outlet_left, NULL, i, atoms);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }
    // final cleanup
    Py_XDECREF(pval);
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}</t>
<t tx="sta.20200612055834.1">@language cython


</t>
<t tx="sta.20200612055834.2"># CRITICAL: STILL CRASHING, works but then crashes!!
cdef send3(self, str name, list args):
    _args = [name] + args
    cdef long argc = &lt;long&gt;len(_args)
    cdef mx.t_atom* argv = px.py_list_to_atom(self.obj, &lt;PyObject*&gt;_args)
    px.py_send(self.obj, mx.gensym(""), argc, argv)
    for i in range(argc):
        mx.sysmem_freeptr(&amp;argv[i])
    mx.sysmem_freeptr(argv)</t>
<t tx="sta.20200612065639.1">#define PY_SSIZE_T_CLEAN
#include "Python.h"

const char* NAME_INT = "INT";
const char* NAME_STR = "STR";
const char* NAME_LST = "LST";
const char* NAME_TUP = "TUP";
const char* NAME_MAP = "MAP";



@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200612065729.1">@path source/py</t>
<t tx="sta.20200612065752.1">
// global identifiers which can be read and written to from c
const char* NAME_INT;
const char* NAME_STR;
const char* NAME_LST;
const char* NAME_TUP;
const char* NAME_MAP;

// use as (PyImport_AppendInittab("globex", PyInit_globex)
PyMODINIT_FUNC PyInit_globex(void);
@language c
@tabwidth -4
</t>
<t tx="sta.20200612065813.1">static PyMethodDef globex_methods[] = {
    { NULL, NULL, 0, NULL } /* Sentinel */
};

</t>
<t tx="sta.20200612065813.2">static PyModuleDef globex_module = {
    PyModuleDef_HEAD_INIT,
    "globex",
    "Examples of global values in a module.",
    -1,
    globex_methods, /* globex_methods */
    NULL,
    NULL,
    NULL,
    NULL,
};

/* Add a dict of {str : int, ...}.
 * Returns 0 on success, 1 on failure.
 */
</t>
<t tx="sta.20200612065813.3">int _add_map_to_module(PyObject* module)
{
    int ret = 0;
    PyObject* pMap = NULL;

    pMap = PyDict_New();
    if (!pMap) {
        goto except;
    }
    /* Load map. */
    if (PyDict_SetItem(pMap, PyBytes_FromString("66"), PyLong_FromLong(66))) {
        goto except;
    }
    if (PyDict_SetItem(pMap, PyBytes_FromString("123"),
                       PyLong_FromLong(123))) {
        goto except;
    }
    /* Add map to module. */
    if (PyModule_AddObject(module, NAME_MAP, pMap)) {
        goto except;
    }
    ret = 0;
    goto finally;
except:
    Py_XDECREF(pMap);
    ret = 1;
finally:
    return ret;
}

PyMODINIT_FUNC PyInit_globex(void)
{
    PyObject* m = NULL;

    m = PyModule_Create(&amp;globex_module);

    if (m == NULL) {
        goto except;
    }
    /* Adding module globals */
    if (PyModule_AddIntConstant(m, NAME_INT, 42)) {
        goto except;
    }
    if (PyModule_AddStringConstant(m, NAME_STR, "String value")) {
        goto except;
    }
    if (PyModule_AddObject(m, NAME_TUP, Py_BuildValue("iii", 66, 68, 73))) {
        goto except;
    }
    if (PyModule_AddObject(m, NAME_LST, Py_BuildValue("[iii]", 66, 68, 73))) {
        goto except;
    }
    /* An invented convenience function for this dict. */
    if (_add_map_to_module(m)) {
        goto except;
    }

    goto finally;
except:
    Py_XDECREF(m);
    m = NULL;
finally:
    return m;
}
</t>
<t tx="sta.20200612114958.1">float pfloat_to_cfloat(t_py* x, PyObject* pfloat)
{
    if (pfloat == NULL)
        goto error;
    
    if PyFloat_Check(pfloat) {
        float cfloat = PyFloat_AsDouble(pfloat);
        if (cfloat == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }
        Py_XDECREF(pfloat);
        return cfloat;
    }

error:
    py_handle_error(x, "float conversion error");
    Py_XDECREF(pfloat);
    return -1.0;
}

void py_handle_float_output(t_py* x, PyObject* pfloat)
{
    float cfloat = pfloat_to_cfloat(x, pfloat); 
    outlet_float(x-&gt;p_outlet_left, cfloat);
    outlet_bang(x-&gt;p_outlet_right);
}</t>
<t tx="sta.20200612115000.1">long plong_to_clong(t_py* x, PyObject* plong)
{
    if (plong == NULL)
        goto error;

    if (PyLong_Check(plong)) {
        long clong = PyLong_AsLong(plong);
        if (clong == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        Py_XDECREF(plong);
        return clong;
    }

error:
    py_handle_error(x, "long conversion error");
    Py_XDECREF(plong);
    return -1;
}

void py_handle_long_output(t_py* x, PyObject* plong)
{
    long clong = plong_to_clong(x, plong); 
    outlet_float(x-&gt;p_outlet_left, clong);
    outlet_bang(x-&gt;p_outlet_right);
}</t>
<t tx="sta.20200612115112.1">const char* pstring_to_cstring(t_py* x, PyObject* pstring)
{
    if (pstring == NULL) {
        goto error;
    }

    if (PyUnicode_Check(pstring)) {
        const char* cstring = PyUnicode_AsUTF8(pstring);
        if (cstring == NULL) {
            goto error;
        }
        Py_XDECREF(pstring);
        return cstring;
    }

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pstring);
    return NULL;
}


void py_handle_string_output(t_py* x, PyObject* pstring) {
    const char* cstring = plong_to_clong(x, pstring);
    outlet_anything(x-&gt;p_outlet_left, gensym(cstring), 0, NIL);
    outlet_bang(x-&gt;p_outlet_right);
}
</t>
<t tx="sta.20200615052024.1">void py_init_builtins(t_py* x)
{
    PyObject* p_name = NULL;
    PyObject* builtins = NULL;
    int err = -1;

    p_name = PyUnicode_FromString(x-&gt;p_name-&gt;s_name);
    if (p_name == NULL)
        goto error;

    builtins = PyEval_GetBuiltins();
    if (builtins == NULL)
        goto error;

    err = PyDict_SetItemString(builtins, "PY_OBJ_NAME", p_name);
    if (err == -1)
        goto error;

    err = PyDict_SetItemString(x-&gt;p_globals, "__builtins__", builtins);
    if (err == -1)
        goto error;

    Py_XDECREF(p_name);
    // Py_XDECREF(builtins);
    return;

error:
    py_handle_error(x, "could not update object namespace with object name");
    Py_XDECREF(p_name);
    // Py_XDECREF(builtins);
}


</t>
<t tx="sta.20200615052054.1">void py_locate_path_from_symbol(t_py* x, t_symbol* s)
{
    t_max_err err;

    if (s == gensym("")) { // if no arg supplied ask for file
        x-&gt;p_code_filename[0] = 0;

        if (open_dialog(x-&gt;p_code_filename, &amp;x-&gt;p_code_path,
                        &amp;x-&gt;p_code_outtype, &amp;x-&gt;p_code_filetype, 1))
            // non-zero: cancelled
            return;

    } else {
        // must copy symbol before calling locatefile_extended
        strncpy_zero(x-&gt;p_code_filename, s-&gt;s_name, MAX_PATH_CHARS);
        if (locatefile_extended(x-&gt;p_code_filename, &amp;x-&gt;p_code_path,
                                &amp;x-&gt;p_code_outtype, &amp;x-&gt;p_code_filetype, 1)) {
            // nozero: not found
            py_error(x, "can't find file %s", s-&gt;s_name);
            return;
        } else {
            x-&gt;p_code_pathname[0] = 0;
            err = path_toabsolutesystempath(x-&gt;p_code_path, x-&gt;p_code_filename,
                                            x-&gt;p_code_pathname);
            if (err != MAX_ERR_NONE) {
                py_error(x, "can't convert %s to absolutepath", s-&gt;s_name);
                return;
            }
        }

        // success
        // set attribute from pathname symbol
        x-&gt;p_code_filepath = gensym(x-&gt;p_code_pathname);
    }
}

void py_appendtodict(t_py* x, t_dictionary* dict)
{
    if (dict) {
        dictionary_appendsym(dict, gensym("file"), x-&gt;p_code_filepath);
        dictionary_appendlong(dict, gensym("autoload"), x-&gt;p_autoload);
    }
}


</t>
<t tx="sta.20200616215024.1"># api.pyx
"""

The main place to create wrappers and utilities to access max's api

See below for examples of this.

- [x] mx.object_method_typed(self.obj, mx.gensym(msg), argc, argv, NULL)
- [ ] t_max_err object_method_parse(t_object *x, t_symbol *s, const char *parsestr, t_atom *rv)


"""
#cimport cython
from cpython cimport PyFloat_AsDouble
from cpython cimport PyLong_AsLong
from cpython.ref cimport PyObject

from libc.stdlib cimport malloc
from libc.string cimport strcpy, strlen

cimport api_max as mx # api is a cython keyword!
cimport api_py as px

import numpy
import numpy as np


DEF MAX_CHARS = 32767
DEF PY_MAX_ATOMS = 128


cdef extern from "Python.h":
    const char* PyUnicode_AsUTF8(object unicode)
    unicode PyUnicode_FromString(const char *u)


cdef class PyAtom:
    """A wrapper class for max t_atom arrays"""
    cdef long argc
    cdef mx.t_atom *argv
    cdef bint ptr_owner

    def __cinit__(self):
        self.argc = 0
        self.argv = NULL
        self.ptr_owner = False

    def __dealloc__(self):
        """De-allocate if not null and flag is set"""
        if self.argv is not NULL and self.ptr_owner is True:
            for i in range(self.argc):
                mx.sysmem_freeptr(&amp;self.argv[i])
            mx.sysmem_freeptr(self.argv)
            self.argc = 0
            self.argv = NULL

    cdef int from_cstr(self, char *parsestr) except -1:
        cdef mx.t_max_err err = mx.atom_setparse(&amp;self.argc, &amp;self.argv, parsestr)
        if err != mx.MAX_ERR_NONE: # test this!!
            raise Exception("cannot convert c parsestring to atom array")
        else:
            return 0

    cpdef from_pstr(self, str parsestr):
        cdef char cparsestring[MAX_CHARS]
        cparsestring = PyUnicode_AsUTF8(parsestr)
        cdef mx.t_max_err err = mx.atom_setparse(&amp;self.argc, &amp;self.argv, cparsestring)
        if err != mx.MAX_ERR_NONE: # test this!!
            raise Exception("cannot convert c parsestring to atom array")

    cpdef str to_pstr(self):
        """atoms -&gt; python string"""
        cdef long textsize = 0
        cdef char* text = NULL
        cdef mx.t_max_err err = mx.atom_gettext(self.argc, self.argv, &amp;textsize, &amp;text, 
            mx.OBEX_UTIL_ATOM_GETTEXT_DEFAULT)
        pstr = PyUnicode_FromString(text)
        mx.sysmem_freeptr(text)
        return pstr

    @staticmethod
    cdef PyAtom from_atom(long argc, mx.t_atom *argv, bint owner=False):
        """Factory function to create PyAtom objects from t_atom pointer.

        Setting `owner` flag to `True` causes the extension type to 
        `free` the structure pointed to by `argv` when the wrapper 
        object is deallocated.
        """
        # Call to __new__ bypasses __init__ constructor
        cdef PyAtom instance = PyAtom.__new__(PyAtom)
        instance.argc = argc
        instance.argv = argv
        instance.ptr_owner = owner
        return instance

    @staticmethod
    cdef PyAtom new(long argc = 0):
        """Factory function to create PyAtom objects with
        newly allocated t_atom"""
        cdef mx.t_atom *argv
        argv = &lt;mx.t_atom *&gt;mx.sysmem_newptr(sizeof(mx.t_atom *) * argc)
        if argv is NULL:
            raise MemoryError
        return PyAtom.from_atom(argc, argv, owner=True)


    @staticmethod
    cdef PyAtom from_list(list elements):
        """Factory function to create PyAtom objects from a python list
        """
        cdef long argc = &lt;long&gt;len(elements)
        cdef mx.t_atom *argv
        # cdef char buff[MAX_CHARS]

        argv = &lt;mx.t_atom *&gt;mx.sysmem_newptr(sizeof(mx.t_atom *) * argc)
        for i, elem in enumerate(elements):
            if type(elem) == float:
                mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
            elif type(elem) == int:
                mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
            elif type(elem) == str:
                # mx.strncpy_zero(buff, elem.encode('utf-8'), MAX_CHARS)
                # mx.atom_setsym((&amp;argv[i]), mx.gensym(buff))
                mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
            else:
                continue
        return PyAtom.from_atom(argc, argv, owner=True)


cdef class PyExternal:
    cdef px.t_py *obj
    cdef bytes name

    def __cinit__(self):
        """Retrieves the py object name and reference.

        PY_OBJ_NAME is set to __builtins__ at object creation
        making it available to all modules.

        Since all py objects are registered, knowing the name
        allows any module in the namespace to get a reference
        (as below) to its parent object (-:
        """
        PY_OBJ_NAME = getattr(__builtins__, 'PY_OBJ_NAME')
        self.name = PY_OBJ_NAME.encode('utf-8')
        self.obj = &lt;px.t_py *&gt;mx.object_findregistered(
            mx.CLASS_BOX, mx.gensym(self.name))

    cpdef bang(self):
        px.py_bang(self.obj)

    def log(self, str s):
        px.py_log(self.obj, s.encode('utf-8'))

    def error(self, str s):
        px.py_error(self.obj, s.encode('utf-8'))

    cdef scan(self):
        px.py_scan(self.obj)

    cdef lookup(self, str name):
        cdef mx.t_hashtab* registry = px.get_global_registry()
        cdef mx.t_object* obj = NULL
        cdef mx.t_max_err err

        if (mx.hashtab_getsize(registry) == 0):
            self.error("registry not populated")
            return

        err = mx.hashtab_lookup(registry, 
            mx.gensym(name.encode('utf-8')), &amp;obj)

        if ((err != mx.MAX_ERR_NONE) or (obj == NULL)):
            self.error("no object found with name")
        else:
            self.log("found object")

    # Wooo!!!
    cdef send0(self, str name, list args):
        _args = [name] + args
        cdef PyAtom atom = PyAtom.from_list(_args)
        px.py_send(self.obj, mx.gensym(""), atom.argc, atom.argv)

    cdef send(self, str name, list args):
        cdef long argc = &lt;long&gt;len(args) + 1
        cdef mx.t_atom argv[PY_MAX_ATOMS]
        _args = [name] + args

        if argc &lt; 1:
            self.error("no arguments given")
            return

        if argc &gt;= PY_MAX_ATOMS - 1:
            self.error("number of args exceeded app limit")
            return

        for i, elem in enumerate(_args):
            if type(elem) == float:
                mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
            elif type(elem) == int:
                mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
            elif type(elem) == str:
                mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
            else:
                continue

        px.py_send(self.obj, mx.gensym(""), argc, argv)


    cdef send4(self, str name, str msg, list args):
        cdef mx.t_object* obj = NULL
        cdef mx.t_symbol* msg_sym = mx.gensym(msg.encode('utf-8'))
        cdef mx.t_hashtab* registry = px.get_global_registry()
        cdef mx.t_max_err err
        cdef mx.t_atom argv[PY_MAX_ATOMS]
        cdef long argc = &lt;long&gt;len(args)

        if argc &lt; 1:
            self.error("no arguments given")
            return

        if argc &gt;= PY_MAX_ATOMS:
            self.error("number of args exceeded app limit")
            return

        for i, elem in enumerate(args):
            if type(elem) == float:
                mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
            elif type(elem) == int:
                mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
            elif type(elem) == str:
                mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
            else:
                continue

        # if registry is empty, scan it
        if (mx.hashtab_getsize(registry) == 0):
            self.log("registry empty, scanning...")
            self.scan()

        # lookup name in registry
        err = mx.hashtab_lookup(registry, mx.gensym(name.encode('utf-8')), &amp;obj)

        if ((err != mx.MAX_ERR_NONE) or (obj == NULL)):
            self.error("no object found with name")
            return

        err = mx.object_method_typed(obj, msg_sym, argc, argv, NULL)

        if (err != mx.MAX_ERR_NONE):
            self.error("send failed")
            mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_middle)
        else:
            self.log("send succeeded")
            mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_right)


    cdef success(self):
        mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_right)

    cdef fail(self):
        mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_middle)

    cdef out_sym(self, str arg):
        mx.outlet_anything(&lt;void*&gt;self.obj.p_outlet_left, 
            mx.gensym(arg.encode('utf-8')), 0, NULL)

    cdef out_float(self, float arg):
        mx.outlet_float(&lt;void*&gt;self.obj.p_outlet_left, &lt;double&gt;arg)

    cdef out_int(self, int arg):
        mx.outlet_int(&lt;void*&gt;self.obj.p_outlet_left, &lt;long&gt;arg)

    cdef out_list_buggy(self, list arg):
        cdef PyAtom atom = PyAtom.from_list(arg)
        mx.outlet_list(&lt;void*&gt;self.obj.p_outlet_left, mx.gensym("list"),
            atom.argc, atom.argv)

    cdef out_list(self, list arg):
        # cdef PyAtom atom = PyAtom.from_list(arg)

        cdef mx.t_atom argv[PY_MAX_ATOMS]
        cdef long argc = &lt;long&gt;len(arg)

        if argc &lt; 1:
            self.error("no arguments given")
            return

        if argc &gt;= PY_MAX_ATOMS:
            self.error("number of args exceeded app limit")
            return

        for i, elem in enumerate(arg):
            if type(elem) == float:
                mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
            elif type(elem) == int:
                mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
            elif type(elem) == str:
                mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
            else:
                continue

        mx.outlet_list(&lt;void*&gt;self.obj.p_outlet_left, 
            mx.gensym("list"), argc, argv)



    cdef out_dict(self, dict arg):
        "note: not recursive... still cannot deal with dict inside dict"
        res = []
        for k,v in arg.items():
            res.append(k)
            res.append(':')
            if type(v) in [list, set, tuple]:
                for i in v:
                    res.append(i)
            else:
                res.append(v)
        self.out_list(res)

    cdef out(self, object arg):
        if isinstance(arg, float): self.out_float(arg)
        elif isinstance(arg, int): self.out_int(arg)
        elif isinstance(arg, str): self.out_sym(arg)
        elif isinstance(arg, list): self.out_list(arg)
        # BUG: below cause crash? not sure why
        elif isinstance(arg, dict): self.out_dict(&lt;dict&gt;arg)
        else:
            return


def test_atom_fromlist(length=10, n=10):
    cdef PyAtom atoms

    xs = list(range(length))
    for i in range(n):
        atoms = PyAtom.from_list(xs)
    return 'ok'


def get_globals():
    return list(globals().keys())

def test():
    ext = PyExternal()
    ext.bang()

def success():
    ext = PyExternal()
    ext.success()

def fail():
    ext = PyExternal()
    ext.fail()

def out_sym(s='hello outlet!'):
    ext = PyExternal()
    ext.out(s)

def out_int(n=100):
    ext = PyExternal()
    ext.out(n)

def out_float(n=12.75):
    ext = PyExternal()
    ext.out(n)

def out_list(xs=[1,2,3,4,5]):
    ext = PyExternal()
    ext.out(xs)

def out_dict(d={'a':[1,2,'a'], 'b':1.3, 'c': 100, 'd':'e'}):
    ext = PyExternal()
    ext.out_dict(d)

def out_dict2():
    d={'a':[1,2,'a'], 'b':1.3, 'c': 100, 'd':'e'}
    ext = PyExternal()
    ext.out(d)

def test_send0(name, value=9.5):
    ext = PyExternal()
    ext.send(name, [value])

def test_send(name, value=11.5):
    ext = PyExternal()
    ext.send(name, [value])
    # del ext

def test_send4(name, msg='float', value=14.5):
    ext = PyExternal()
    ext.send4(name, msg, [value])
    # del ext



def lookup(name):
    ext = PyExternal()
    ext.lookup(name)



# ext = PyExternal()

txt = "Hey MAX!"

greeting = 'Hello World'


cpdef public str hello():
    return greeting


def random(int n):
    return np.random.rand(n)


def echo(*args):
    return args


def total(*args):
    return sum(args)


def post(str s):
    mx.post(s.encode('utf-8'))


def error(str s):
    mx.error(s.encode('utf-8'))




</t>
<t tx="sta.20200618151814.1">### Cython/Python Scripting Example

For example, let's assume we want to enable sending arbitrary messages to other objects in a patcher (a la `thispatcher`).

To simplify things, we want to send a list of floats to a `coll` object:

I would first import the `api` builtin module
```
[ import api]
```
followed by sending this message to the `py` object
```
[ call api.send coll1 5.1 9.2 10.8 11.5 ]
```
or from python code:

```python
import api
api.send('coll1', [5.1, 9.2, 10.8, 11.5])
```

Since I want to use the `call` method which is used for max friendly python function calls, I have to write a small helper module function in `api.pyx`:

```python
def send(args):
    name = args[:1] # head
    msg = args[1:]  # tail
    ext = PyExternal()
    ext.send(name, msg)
```

This calls the `PyExternal` class which, in the `api` module, encapsulates some essential common functionality such getting a reference to the parent object and having a bunch of useful methods which call the max api directly or indirectly via external c code.

```cython
cdef class PyExternal:
    cdef px.t_py *obj

    def __cinit__(self, bytes name=__name__.encode('utf-8')):
        self.obj = &lt;px.t_py *&gt;mx.object_findregistered(
            mx.CLASS_BOX, mx.gensym(name))

    # methods follow ...
```

Now for the send method itself. There are at least two ways to implement this:

- As a `send` method in your external. My implementation (for the py object) is 101 lines according to `wc -l` and has the following prototype

```c
void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv)
```

- As a send method in your cython `api.pyx` file so it can be called by python scripts and also via messages. I actually made 3 versions

1. A version which wraps the previously implemented `py_send` and uses a cython Atom extension type which encapsulate `t_atom` arrays: 4 lines

```python
cdef send1(self, str name, list args):
    _args = [name] + args
    cdef PyAtom atom = PyAtom.from_list(_args)
    px.py_send(self.obj, mx.gensym(""), atom.argc, atom.argv)
```

2. A version which implements calls `py_send` using a statically allocated `t_atom` array: 19 lines

```python
cdef send2(self, str name, list args):
    cdef long argc = &lt;long&gt;len(args) + 1
    cdef mx.t_atom argv[PY_MAX_ATOMS]
    _args = [name] + args

    if argc &lt; 1:
        self.error("no arguments given")
        return

    if argc &gt;= PY_MAX_ATOMS - 1:
        self.error("number of args exceeded app limit")
        return

    for i, elem in enumerate(_args):
        if type(elem) == float:
            mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
        elif type(elem) == int:
            mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
        elif type(elem) == str:
            mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
        else:
            continue

    px.py_send(self.obj, mx.gensym(""), argc, argv)
```

3. A version which re-implements `py_send` in cython: 38 lines 

```python
cdef send3(self, str name, str msg, list args):
    cdef mx.t_object* obj = NULL
    cdef mx.t_symbol* msg_sym = mx.gensym(msg.encode('utf-8'))
    cdef mx.t_hashtab* registry = px.get_global_registry()
    cdef mx.t_max_err err
    cdef mx.t_atom argv[PY_MAX_ATOMS]
    cdef long argc = &lt;long&gt;len(args)

    if argc &lt; 1:
        self.error("no arguments given")
        return

    if argc &gt;= PY_MAX_ATOMS:
        self.error("number of args exceeded app limit")
        return

    for i, elem in enumerate(args):
        if type(elem) == float:
            mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
        elif type(elem) == int:
            mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
        elif type(elem) == str:
            mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
        else:
            continue

    # if registry is empty, scan it
    if (mx.hashtab_getsize(registry) == 0):
        self.log("registry empty, scanning...")
        self.scan()

    # lookup name in registry
    err = mx.hashtab_lookup(registry, mx.gensym(name.encode('utf-8')), &amp;obj)

    if ((err != mx.MAX_ERR_NONE) or (obj == NULL)):
        self.error("no object found with name")
        return

    err = mx.object_method_typed(obj, msg_sym, argc, argv, NULL)

    if (err != mx.MAX_ERR_NONE):
        self.error("send failed")
        mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_middle)
    else:
        self.log("send succeeded")
        mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_right)
```

</t>
<t tx="sta.20200619105724.1">void py_pipe(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    t_max_err err;
    PyObject* pipe_pre = NULL;
    PyObject* pipe_fun = NULL;
    PyObject* pval = NULL;
    PyObject* pstr = NULL;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err != MAX_ERR_NONE || !textsize || !text) {
        py_error(x, "atom -&gt; text conversion failed");
        goto error;
    }

    pipe_pre = PyRun_String("def __py_maxmsp_pipe(arg):\n"
                            "\targs = arg.split()\n"
                            "\tval = eval(args[0])\n"
                            "\tfuncs = [eval(f) for f in args[1:]]\n"
                            "\tfor f in funcs:\n"
                            "\t\tval = f(val)\n"
                            "\treturn val\n",
                            Py_single_input, x-&gt;p_globals, x-&gt;p_globals);

    if (pipe_pre == NULL) {
        py_error(x, "pipe func is NULL");
        goto error;
    }

    pstr = PyUnicode_FromString(text);
    if (pstr == NULL) {
        py_error(x, "cstr -&gt; pyunicode conversion failed");
        goto error;
    }

    sysmem_freeptr(text);

    pipe_fun = PyDict_GetItemString(x-&gt;p_globals, "__py_maxmsp_pipe");
    if (pipe_fun == NULL) {
        py_error(x, "retrieving pipe func from globals failed");
        goto error;
    }

    pval = PyObject_CallFunctionObjArgs(pipe_fun, pstr, NULL);

    if (pval != NULL) {

        if (!PyUnicode_Check(pval)) {
            py_handle_output(x, pval); // this decrefs pval
        } else {
            // special case strings, which will cause crash if handled
            // out of this methods's scope. (huge PITA to debug!)
            const char* unicode_result = PyUnicode_AsUTF8(pval);
            if (unicode_result == NULL) {
                goto error;
            }
            outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
            outlet_bang(x-&gt;p_outlet_right);
            Py_XDECREF(pval);
        }

        Py_XDECREF(pipe_pre);
        Py_XDECREF(pstr);
        outlet_bang(x-&gt;p_outlet_right);
        return;
    } else {
        goto error;
    }

error:
    py_handle_error(x, "pipe failed");
    Py_XDECREF(pipe_pre);
    Py_XDECREF(pstr);
    Py_XDECREF(pval);
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200619105805.1">void py_pipe_c(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    // working but incomplete implementation which
    // can't handle dotted ids in globals
    // abandoned for current py version
    PyObject* list = NULL;
    PyObject* item = NULL;
    PyObject* funcs = NULL;
    PyObject* funcs_iter = NULL;
    PyObject* func = NULL;
    PyObject* pval = NULL;

    list = py_atoms_to_list(x, argc, argv, 0);
    if (list == NULL) {
        goto error;
    }

    if (argc &lt; 2) {
        py_error(x, "pipe needs at least two arguments.\n");
        goto error;
    }

    pval = PyList_GetItem(list, 0);
    if (pval == NULL) {
        py_error(x, "could not retrieve input value\n");
        goto error;
    }

    funcs = PyList_GetSlice(list, 1, argc);
    if (funcs == NULL || !PyList_Check(funcs)) {
        py_error(x, "could not retrieve function names\n");
        goto error;
    }

    funcs_iter = PyObject_GetIter(funcs);
    if (funcs_iter == NULL) {
        goto error;
    }

    PyObject* builtins = PyDict_GetItemString(x-&gt;p_globals, "__builtins__");

    while ((item = PyIter_Next(funcs_iter)) != NULL) {

        func = PyDict_GetItemWithError(x-&gt;p_globals, item);
        if (func == NULL) {
            if (!PyDict_Contains(builtins, item)) {
                py_error(x, "not a builtin nor in globals\n");
                goto error;
            }
            else {
                func = PyDict_GetItemWithError(builtins, item);
                if (func == NULL) {
                    py_error(x, "unable to to retrieve func without error\n");
                    goto error;
                }
            }
        }

        if (!PyCallable_Check(func)) {
            py_error(x, "object retrieved is not a callable\n");
            goto error;
        }

        pval = PyObject_CallFunctionObjArgs(func, pval, NULL);
        if (pval == NULL) {
            py_error(x, "error occurred returning output from func\n");
            goto error;
        }
        Py_DECREF(func);
        Py_DECREF(item);
    }
    Py_XDECREF(funcs_iter);

    if (pval != NULL) {
        if (!PyUnicode_Check(pval)) {
            py_handle_output(x, pval); // this decrefs pval
        } else {
            // special case strings, which will cause crash if handle out
            // of this methods's scope.
            const char* unicode_result = PyUnicode_AsUTF8(pval);
            if (unicode_result == NULL) {
                goto error;
            }
            outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
            outlet_bang(x-&gt;p_outlet_right);
            Py_XDECREF(pval);
        }
        Py_XDECREF(list);
        Py_XDECREF(funcs);
        return;
    }

error:
    py_handle_error(x, "pipe failed");
    Py_XDECREF(list);
    Py_XDECREF(funcs);
    Py_XDECREF(pval);
}
</t>
<t tx="sta.20200619110720.1"></t>
<t tx="sta.20200620071935.1"># api.pyx
@others
@language cython
@tabwidth -4
</t>
<t tx="sta.20200620071950.1">"""

The main place to create wrappers and utilities to access max's api

See below for examples of this.

- [x] mx.object_method_typed(self.obj, mx.gensym(msg), argc, argv, NULL)
- [ ] t_max_err object_method_parse(t_object *x, t_symbol *s, const char *parsestr, t_atom *rv)


"""
#cimport cython
from cpython cimport PyFloat_AsDouble
from cpython cimport PyLong_AsLong
from cpython.ref cimport PyObject

from libc.stdlib cimport malloc
from libc.string cimport strcpy, strlen

cimport api_max as mx # api is a cython keyword!
cimport api_py as px

import numpy
import numpy as np


DEF MAX_CHARS = 32767
DEF PY_MAX_ATOMS = 128

cdef extern from "Python.h":
    const char* PyUnicode_AsUTF8(object unicode)
    unicode PyUnicode_FromString(const char *u)




</t>
<t tx="sta.20200620071950.10">cdef scan(self):
    px.py_scan(self.obj)

</t>
<t tx="sta.20200620071950.11">cdef lookup(self, str name):
    cdef mx.t_hashtab* registry = px.get_global_registry()
    cdef mx.t_object* obj = NULL
    cdef mx.t_max_err err

    if (mx.hashtab_getsize(registry) == 0):
        self.error("registry not populated")
        return

    err = mx.hashtab_lookup(registry, 
        mx.gensym(name.encode('utf-8')), &amp;obj)

    if ((err != mx.MAX_ERR_NONE) or (obj == NULL)):
        self.error("no object found with name")
    else:
        self.log("found object")

# UNTESTED
</t>
<t tx="sta.20200620071950.12">cdef str atoms_to_pstring(self, long argc, mx.t_atom* argv):
    """atoms -&gt; python string"""
    cdef long textsize = 0
    cdef char* text = NULL
    cdef mx.t_max_err err = mx.atom_gettext(argc, argv, &amp;textsize, &amp;text, 
        mx.OBEX_UTIL_ATOM_GETTEXT_DEFAULT)
    pstr = PyUnicode_FromString(text)
    mx.sysmem_freeptr(text)
    return pstr

# UNTESTED
</t>
<t tx="sta.20200620071950.13">cdef int pstring_to_atoms(self, str parsestr, long argc, mx.t_atom *argv) except -1:
    cdef char cparsestring[MAX_CHARS]
    cparsestring = PyUnicode_AsUTF8(parsestr)
    cdef mx.t_max_err err = mx.atom_setparse(&amp;argc, &amp;argv, cparsestring)
    if err != mx.MAX_ERR_NONE: # test this!!
        raise Exception("cannot convert c parsestring to atom array")

# UNTESTED
</t>
<t tx="sta.20200620071950.14">cdef int cstring_to_atoms(self, char *parsestr, long argc, mx.t_atom *argv) except -1:
    cdef mx.t_max_err err = mx.atom_setparse(&amp;argc, &amp;argv, parsestr)
    if err != mx.MAX_ERR_NONE: # test this!!
        raise Exception("cannot convert c parsestring to atom array")
    else:
        return 0

</t>
<t tx="sta.20200620071950.15">cdef send(self, str name, list args):
    cdef long argc = &lt;long&gt;len(args) + 1
    cdef mx.t_atom argv[PY_MAX_ATOMS]
    _args = [name] + args

    if argc &lt; 1:
        self.error("no arguments given")
        return

    if argc &gt;= PY_MAX_ATOMS - 1:
        self.error("number of args exceeded app limit")
        return

    for i, elem in enumerate(_args):
        if type(elem) == float:
            mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
        elif type(elem) == int:
            mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
        elif type(elem) == str:
            mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
        else:
            continue
    # mx.postatom(argv)
    px.py_send(self.obj, mx.gensym(""), argc, argv)

</t>
<t tx="sta.20200620071950.16">cdef success(self):
    mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_right)

</t>
<t tx="sta.20200620071950.17">cdef fail(self):
    mx.outlet_bang(&lt;void*&gt;self.obj.p_outlet_middle)

</t>
<t tx="sta.20200620071950.18">cdef out_sym(self, str arg):
    mx.outlet_anything(&lt;void*&gt;self.obj.p_outlet_left, 
        mx.gensym(arg.encode('utf-8')), 0, NULL)

</t>
<t tx="sta.20200620071950.19">cdef out_float(self, float arg):
    mx.outlet_float(&lt;void*&gt;self.obj.p_outlet_left, &lt;double&gt;arg)

</t>
<t tx="sta.20200620071950.20">cdef out_int(self, int arg):
    mx.outlet_int(&lt;void*&gt;self.obj.p_outlet_left, &lt;long&gt;arg)

</t>
<t tx="sta.20200620071950.21">cdef out_list(self, list arg):
    """note: not recursive...(yet) still cannot deal with list in list"""
    cdef long argc = &lt;long&gt;len(arg)
    cdef mx.t_atom argv[PY_MAX_ATOMS]

    if argc &gt;= PY_MAX_ATOMS :
        self.error("number of args exceeded app limit")
        return

    for i, elem in enumerate(arg):
        if type(elem) == float:
            mx.atom_setfloat(&amp;argv[i], &lt;double&gt;elem)
        elif type(elem) == int:
            mx.atom_setlong((&amp;argv[i]), &lt;long&gt;elem)
        elif type(elem) == str:
            mx.atom_setsym((&amp;argv[i]), mx.gensym(elem.encode('utf-8')))
        else:
            continue

    mx.outlet_list(&lt;void*&gt;self.obj.p_outlet_left, mx.gensym("list"),
        argc, argv)

</t>
<t tx="sta.20200620071950.22">cdef out_dict(self, dict arg):
    """note: not recursive...(yet) still cannot deal with dict in dict"""
    res = []
    for k,v in arg.items():
        res.append(k)
        res.append(':')
        if type(v) in [list, set, tuple]:
            for i in v:
                res.append(i)
        else:
            res.append(v)
    self.out_list(res)

</t>
<t tx="sta.20200620071950.23">cdef out(self, object arg):
    if isinstance(arg, float): self.out_float(arg)
    elif isinstance(arg, int): self.out_int(arg)
    elif isinstance(arg, str): self.out_sym(arg)
    elif isinstance(arg, list): self.out_list(arg)
    # BUG: below cause crash? not sure why
    elif isinstance(arg, dict): self.out_dict(&lt;dict&gt;arg)
    else:
        return


</t>
<t tx="sta.20200620071950.24">def get_globals():
    return list(globals().keys())

</t>
<t tx="sta.20200620071950.25">def bang():
    ext = PyExternal()
    ext.bang()
</t>
<t tx="sta.20200620071950.26">def success():
    ext = PyExternal()
    ext.success()
</t>
<t tx="sta.20200620071950.27">def fail():
    ext = PyExternal()
    ext.fail()
</t>
<t tx="sta.20200620071950.28">def out_sym(s='hello outlet!'):
    ext = PyExternal()
    ext.out(s)

</t>
<t tx="sta.20200620071950.29">def out_int(n=100):
    ext = PyExternal()
    ext.out(n)

</t>
<t tx="sta.20200620071950.3">cdef class PyExternal:
    @others
</t>
<t tx="sta.20200620071950.30">def out_float(n=12.75):
    ext = PyExternal()
    ext.out(n)

</t>
<t tx="sta.20200620071950.31">def out_list(xs=[1,'a','c',4,5]):
    ext = PyExternal()
    ext.out(xs)

</t>
<t tx="sta.20200620071950.32">def out_dict(**kwargs):
    if not kwargs:
        kwargs = {'a':[1,2,'a'], 'b':1.3, 'c': 100, 'd':'e'}
    ext = PyExternal()
    ext.out(kwargs)

</t>
<t tx="sta.20200620071950.33">def send(name='mrfloat', value=9.5):
    ext = PyExternal()
    ext.send(name, [value])

</t>
<t tx="sta.20200620071950.34">def lookup(name):
    ext = PyExternal()
    ext.lookup(name)



</t>
<t tx="sta.20200620071950.35">cpdef public str hello():
    return greeting


</t>
<t tx="sta.20200620071950.36">def random(int n):
    return np.random.rand(n)


</t>
<t tx="sta.20200620071950.37">def echo(*args):
    return args


</t>
<t tx="sta.20200620071950.38">def total(*args):
    return sum(args)


</t>
<t tx="sta.20200620071950.39">def post(str s):
    mx.post(s.encode('utf-8'))


</t>
<t tx="sta.20200620071950.40">def error(str s):
    mx.error(s.encode('utf-8'))




</t>
<t tx="sta.20200620071950.6">def __cinit__(self):
    """Retrieves the py object name and reference.

    PY_OBJ_NAME is set to __builtins__ at object creation
    making it available to all modules.

    Since all py objects are registered, knowing the name
    allows any module in the namespace to get a reference
    (as below) to its parent object.
    """
    PY_OBJ_NAME = getattr(__builtins__, 'PY_OBJ_NAME')
    self.name = PY_OBJ_NAME.encode('utf-8')
    self.obj = &lt;px.t_py *&gt;mx.object_findregistered(
        mx.CLASS_BOX, mx.gensym(self.name))

</t>
<t tx="sta.20200620071950.7">cpdef bang(self):
    px.py_bang(self.obj)

</t>
<t tx="sta.20200620071950.8">def log(self, str s):
    px.py_log(self.obj, s.encode('utf-8'))

</t>
<t tx="sta.20200620071950.9">def error(self, str s):
    px.py_error(self.obj, s.encode('utf-8'))

</t>
<t tx="sta.20200620112807.1"></t>
<t tx="sta.20200620112906.1"></t>
<t tx="sta.20200620113654.1">cdef px.t_py *obj
cdef bytes name

</t>
<t tx="sta.20200620113747.1"></t>
<t tx="sta.20200620113814.1"></t>
<t tx="sta.20200620113843.1"></t>
<t tx="sta.20200620164702.1"># ext = PyExternal()

txt = "Hey MAX!"

greeting = 'Hello World'


</t>
<t tx="sta.20200621080125.1">void py_handle_dict_output(t_py* x, PyObject* pdict)
{
    PyObject* pfun_co = NULL;
    PyObject* pfun = NULL;
    PyObject* pval = NULL;

    if (pdict == NULL) {
        goto error;
    }

    if (PyDict_Check(pdict)) {

        pfun_co = PyRun_String("def __py_maxmsp_out_dict(arg):\n"
                               "\tres = []\n"
                               "\tfor k,v in arg.items():\n"
                               "\t\tres.append(k)\n"
                               "\t\tres.append(':')\n"
                               "\t\tif type(v) in [list, set, tuple]:\n"
                               "\t\t\tfor i in v:\n"
                               "\t\t\t\tres.append(i)\n"
                               "\t\telse:\n"
                               "\t\t\tres.append(v)\n"
                               "\treturn res\n",
                               Py_single_input, x-&gt;p_globals, x-&gt;p_globals);

        if (pfun_co == NULL) {
            py_error(x, "out_dict function code object is NULL");
            goto error;
        }

        pfun = PyDict_GetItemString(x-&gt;p_globals, "__py_maxmsp_out_dict");
        if (pfun == NULL) {
            py_error(x, "retrieving out_dict func from globals failed");
            goto error;
        }

        pval = PyObject_CallFunctionObjArgs(pfun, pdict, NULL);
        if (pval == NULL) {
            py_error(x, "out_dict call failed to retrieve result");
            goto error;
        }

        if (PyList_Check(pval)) {           // expecting a python list
            py_handle_list_output(x, pval); // this decrefs pval
            Py_XDECREF(pfun_co);
            outlet_bang(x-&gt;p_outlet_right);
            return;
        } else {
            py_error(x, "expected list output got something else");
            goto error;
        }
    }

error:
    py_handle_error(x, "py_handle_dict_output failed");
    Py_XDECREF(pfun_co);
    Py_XDECREF(pval);
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}


</t>
<t tx="sta.20200628230341.1">#include "ext.h"
#include "ext_obex.h"

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

#ifdef PY_STATIC_EXT
#include &lt;libgen.h&gt;
#endif
@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200628230354.1">typedef struct _pyjs {
    /* object header */
    t_object p_ob;
    /* python-related */
    PyObject* p_globals;       /* per object 'globals' python namespace */
    t_symbol* p_name;          /* unique object name */
    t_symbol* p_pythonpath;    /* path to python directory */
    t_symbol* p_code_filepath; /* python filepath */
    t_bool p_debug;            /* bool to switch per-object debug state */
} t_pyjs;


void* pyjs_new(t_symbol* s, long argc, t_atom* argv);
</t>
<t tx="sta.20200628230354.10">void pyjs_locate_path_from_symbol(t_pyjs* x, t_symbol* s)
{
    t_fourcc p_code_filetype = FOUR_CHAR_CODE('TEXT');
    t_fourcc p_code_outtype = 0;
    char p_code_filename[MAX_PATH_CHARS];
    char p_code_pathname[MAX_PATH_CHARS];
    short p_code_path;
    t_max_err err;

    if (s == gensym("")) { // if no arg supplied ask for file
        p_code_filename[0] = 0;

        if (open_dialog(p_code_filename, &amp;p_code_path, &amp;p_code_outtype,
                        &amp;p_code_filetype, 1))
            // non-zero: cancelled
            return;

    } else {
        // must copy symbol before calling locatefile_extended
        strncpy_zero(p_code_filename, s-&gt;s_name, MAX_PATH_CHARS);
        if (locatefile_extended(p_code_filename, &amp;p_code_path, &amp;p_code_outtype,
                                &amp;p_code_filetype, 1)) {
            // nozero: not found
            pyjs_error(x, "can't find file %s", s-&gt;s_name);
            return;
        } else {
            p_code_pathname[0] = 0;
            err = path_toabsolutesystempath(p_code_path, p_code_filename,
                                            p_code_pathname);
            if (err != MAX_ERR_NONE) {
                pyjs_error(x, "can't convert %s to absolutepath", s-&gt;s_name);
                return;
            }
        }

        // success
        // set attribute from pathname symbol
        x-&gt;p_code_filepath = gensym(p_code_pathname);
    }
}


</t>
<t tx="sta.20200628230354.2">{
    t_class* c;

    c = class_new("pyjs", (method)pyjs_new, (method)pyjs_free,
                  (long)sizeof(t_pyjs), 0L /* leave NULL!! */, A_GIMME, 0);

    // methods
    class_addmethod(c, (method)pyjs_import,   "import",   A_SYM, 0);
    class_addmethod(c, (method)pyjs_eval,     "eval",     A_GIMMEBACK, 0);
    class_addmethod(c, (method)pyjs_exec,     "exec",     A_SYM, 0);
    class_addmethod(c, (method)pyjs_execfile, "execfile", A_SYM, 0);
    class_addmethod(c, (method)pyjs_code,     "code",     A_GIMMEBACK, 0);
    class_addmethod(c, (method)pyjs_eval_to_json, "eval_to_json", A_GIMMEBACK, 0);

    // attributes
    CLASS_ATTR_SYM(c, "name", 0, t_pyjs, p_name);
    CLASS_ATTR_CHAR(c, "debug", 0, t_pyjs, p_debug);
    CLASS_ATTR_SYM(c, "file", 0, t_pyjs, p_code_filepath);
    CLASS_ATTR_SYM(c, "pythonpath", 0, t_pyjs, p_pythonpath);

    // activate for javascript wrapping
    c-&gt;c_flags = CLASS_FLAG_POLYGLOT;
    class_register(CLASS_NOBOX, c);
    pyjs_class = c;
}

</t>
<t tx="sta.20200628230354.3">void pyjs_free(t_pyjs* x)
{
    Py_XDECREF(x-&gt;p_globals);
    pyjs_log(x, "will be deleted");
    pyjs_global_obj_count--;
    if (pyjs_global_obj_count == 0) {
        Py_FinalizeEx();
    }
}


</t>
<t tx="sta.20200628230354.4">void* pyjs_new(t_symbol* s, long argc, t_atom* argv)
{
    t_pyjs* x = NULL;

    // object instantiation, NEW STYLE
    if ((x = (t_pyjs*)object_alloc(pyjs_class))) {
        // Initialize values

        if (pyjs_global_obj_count == 0) {
            // first py obj is called '__main__'
            x-&gt;p_name = gensym("__main__");
        } else {
            x-&gt;p_name = symbol_unique();
        }
        // x-&gt;p_name = symbol_unique();

        x-&gt;p_pythonpath = gensym("");
        x-&gt;p_debug = 1;
        x-&gt;p_code_filepath = gensym("");

        // process @arg attributes
        attr_args_process(x, argc, argv);

        // python init
        pyjs_init(x);
    }
    return (x);
}


</t>
<t tx="sta.20200628230354.5">void pyjs_init_builtins(t_pyjs* x)
{
    PyObject* p_name = NULL;
    PyObject* builtins = NULL;
    int err = -1;

    p_name = PyUnicode_FromString(x-&gt;p_name-&gt;s_name);
    if (p_name == NULL)
        goto error;

    builtins = PyEval_GetBuiltins();
    if (builtins == NULL)
        goto error;

    err = PyDict_SetItemString(builtins, "PY_OBJ_NAME", p_name);
    if (err == -1)
        goto error;

    err = PyDict_SetItemString(x-&gt;p_globals, "__builtins__", builtins);
    if (err == -1)
        goto error;

    Py_XDECREF(p_name);
    return;

error:
    pyjs_handle_error(x, "could not update object namespace with object name");
    Py_XDECREF(p_name);
}


</t>
<t tx="sta.20200628230354.6">void pyjs_init(t_pyjs* x)
{

    #ifdef PY_STATIC_EXT
    wchar_t *python_home;

    CFBundleRef bundle;
    CFURLRef resources_url;
    CFURLRef resources_abs_url;
    CFStringRef resources_str;
    const char* resources_path;

    // Look for a bundle using its identifier
    bundle = CFBundleGetBundleWithIdentifier(CFSTR("org.me.pyjs"));
    resources_url = CFBundleCopyResourcesDirectoryURL(bundle);
    resources_abs_url = CFURLCopyAbsoluteURL(resources_url);
    resources_str = CFURLCopyFileSystemPath(resources_abs_url, kCFURLPOSIXPathStyle);
    resources_path = CFStringGetCStringPtr(resources_str, kCFStringEncodingUTF8);
    python_home = Py_DecodeLocale(resources_path, NULL);    

    // CFRelease(resources_url);
    // CFRelease(resources_abs_url);
    // CFRelease(resources_str);
    // CFRelease(resources_path);

    post("resources_path: %s", resources_path);

    if (python_home == NULL) {
        error("python_home is NULL");
        // return;
    }
    Py_SetPythonHome(python_home);

    #endif

    Py_Initialize();

    // python init
    PyObject* main_mod = PyImport_AddModule(x-&gt;p_name-&gt;s_name); // borrowed
    x-&gt;p_globals = PyModule_GetDict(main_mod); // borrowed reference
    pyjs_init_builtins(x); // does this have to be a separate function?

    // increment global object counter
    pyjs_global_obj_count++;
}


</t>
<t tx="sta.20200628230354.7">void pyjs_log(t_pyjs* x, char* fmt, ...)
{
    if (x-&gt;p_debug) {
        char msg[PY_MAX_LOG_CHAR];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        post("[pyjs %s]: %s", x-&gt;p_name-&gt;s_name, msg);
    }
}


</t>
<t tx="sta.20200628230354.8">void pyjs_error(t_pyjs* x, char* fmt, ...)
{
    char msg[PY_MAX_ERR_CHAR];

    va_list va;
    va_start(va, fmt);
    vsprintf(msg, fmt, va);
    va_end(va);

    error("[pyjs %s]: %s", x-&gt;p_name-&gt;s_name, msg);
}

</t>
<t tx="sta.20200628230354.9">void pyjs_handle_error(t_pyjs* x, char* fmt, ...)
{
    if (PyErr_Occurred()) {

        // build custom msg
        char msg[PY_MAX_ERR_CHAR];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        // get error info
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        PyErr_NormalizeException(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        Py_XDECREF(ptype);

        PyObject* pvalue_pstr = PyObject_Repr(pvalue);
        const char* pvalue_str = PyUnicode_AsUTF8(pvalue_pstr);
        Py_XDECREF(pvalue);
        Py_XDECREF(pvalue_pstr);

        Py_XDECREF(ptraceback);

        error("[pyjs %s] %s: %s", x-&gt;p_name-&gt;s_name, msg, pvalue_str);
    }
}
</t>
<t tx="sta.20200628230504.1">void pyjs_free(t_pyjs* x);
void pyjs_init(t_pyjs* x);
void pyjs_init_builtins(t_pyjs* x);
void pyjs_log(t_pyjs* x, char* fmt, ...);
void pyjs_error(t_pyjs* x, char* fmt, ...);
void pyjs_handle_error(t_pyjs* x, char* fmt, ...);
void pyjs_locate_path_from_symbol(t_pyjs* x, t_symbol* s);
t_max_err pyjs_import(t_pyjs* x, t_symbol* s);
t_max_err pyjs_exec(t_pyjs* x, t_symbol* s);
t_max_err pyjs_execfile(t_pyjs* x, t_symbol* s);
t_max_err pyjs_eval(t_pyjs* x, t_symbol* s, long argc, t_atom* argv, t_atom* rv);
t_max_err pyjs_eval_to_json(t_pyjs* x, t_symbol* s, long argc, t_atom* argv, t_atom* rv);
t_max_err pyjs_code(t_pyjs* x, t_symbol* s, long argc, t_atom* argv, t_atom* rv);
t_max_err pyjs_handle_output(t_pyjs* x, PyObject* pval, t_atom* rv);
t_max_err pyjs_handle_float_output(t_pyjs* x, PyObject* pfloat, t_atom* rv);
t_max_err pyjs_handle_long_output(t_pyjs* x, PyObject* plong, t_atom* rv);
t_max_err pyjs_handle_list_output(t_pyjs* x, PyObject* plist, t_atom* rv);
t_max_err pyjs_handle_dict_output(t_pyjs* x, PyObject* pdict, t_atom* rv);


</t>
<t tx="sta.20200628230621.1">/* globals */
static t_class* pyjs_class;
static int pyjs_global_obj_count; // when 0 then free interpreter

void ext_main(void* r)
</t>
<t tx="sta.20200628230717.1">
#define PY_MAX_ATOMS 128
#define PY_MAX_LOG_CHAR 500 // high number during development
#define PY_MAX_ERR_CHAR PY_MAX_LOG_CHAR


</t>
<t tx="sta.20200628231022.1">t_max_err pyjs_execfile(t_pyjs* x, t_symbol* s)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (s != gensym("")) {
        // set x-&gt;p_code_filepath
        pyjs_locate_path_from_symbol(x, s);
    }

    if (s == gensym("") || x-&gt;p_code_filepath == gensym("")) {
        pyjs_error(x, "could not set filepath");
        goto error;
    }

    // assume x-&gt;p_code_filepath has be been set without errors

    pyjs_log(x, "pathname: %s", x-&gt;p_code_filepath-&gt;s_name);
    fhandle = fopen(x-&gt;p_code_filepath-&gt;s_name, "r+");

    if (fhandle == NULL) {
        pyjs_error(x, "could not open file");
        goto error;
    }

    pval = PyRun_File(fhandle, x-&gt;p_code_filepath-&gt;s_name, Py_file_input,
                      x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "execfile failed");
    Py_XDECREF(pval);
    return MAX_ERR_GENERIC;
}


</t>
<t tx="sta.20200628231024.1">t_max_err pyjs_exec(t_pyjs* x, t_symbol* s)
{
    PyObject* pval = NULL;

    if (s == gensym("")) {
        pyjs_log(x, "no input given");
        goto error;
    }

    pval = PyRun_String(s-&gt;s_name, Py_single_input, x-&gt;p_globals,
                        x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);
    pyjs_log(x, "exec %s", s-&gt;s_name);
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "exec %s", s-&gt;s_name);
    Py_XDECREF(pval);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231202.1">

t_max_err pyjs_eval_to_json(t_pyjs* x, t_symbol* s, long argc, t_atom* argv,
                            t_atom* rv)
{
    t_atom atoms[PY_MAX_ATOMS];
    PyObject* pval = NULL;
    PyObject* json_module = NULL;
    PyObject* json_dict = NULL;
    PyObject* json_dumps = NULL;
    PyObject* json_pstr = NULL;

    char* cstring = atom_getsym(argv)-&gt;s_name;

    pval = PyRun_String(cstring, Py_eval_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL)
        goto error;

    json_module = PyImport_ImportModule("json");
    if (json_module == NULL)
        goto error;

    json_dict = PyModule_GetDict(json_module); // borrowed ref
    if (json_dict == NULL)
        goto error;

    json_dumps = PyDict_GetItemString(json_dict, "dumps"); // borrowed ref
    if (json_dumps == NULL)
        goto error;

    json_pstr = PyObject_CallFunctionObjArgs(json_dumps, pval, NULL);
    if (json_pstr == NULL)
        goto error;

    const char* unicode_result = PyUnicode_AsUTF8(json_pstr);
    if (unicode_result == NULL)
        goto error;

    atom_setsym(atoms, gensym(unicode_result));
    atom_setobj(rv,
                object_new(gensym("nobox"), gensym("atomarray"), 1, atoms));

    Py_XDECREF(pval);
    Py_XDECREF(json_module);
    Py_XDECREF(json_pstr);

    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "pyjs_eval_to_json failed");
    Py_XDECREF(pval);
    Py_XDECREF(json_module);
    Py_XDECREF(json_pstr);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231411.1">                    t_atom* rv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* co = NULL;
    PyObject* pval = NULL;
    t_max_err err;
    int is_eval = 1;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        pyjs_log(x, "&gt;&gt;&gt; %s", text);
    } else {
        goto error;
    }

    co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_eval_input);

    if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
        PyErr_Clear();
        co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_single_input);
        is_eval = 0;
    }
    pyjs_log(x, "code is_eval: %d", is_eval);

    if (co == NULL) { // can be eval-co or exec-co or NULL here
        goto error;
    }
    sysmem_freeptr(text);

    pval = PyEval_EvalCode(co, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    Py_DECREF(co);

    if (is_eval) {
        pyjs_handle_output(x, pval, rv);
    } else {
        Py_XDECREF(pval);
    }
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "pyjs code failed");
    Py_XDECREF(pval);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231428.1">

t_max_err pyjs_import(t_pyjs* x, t_symbol* s)
{
    PyObject* x_module = NULL;

    if (s != gensym("")) {
        x_module = PyImport_ImportModule(s-&gt;s_name);
        
        if (x_module == NULL) {
            goto error;
        }

        PyDict_SetItemString(x-&gt;p_globals, s-&gt;s_name, x_module);
        pyjs_log(x, "imported: %s", s-&gt;s_name);
        return MAX_ERR_NONE;
    }    

error:
    pyjs_handle_error(x, "import %s", s-&gt;s_name);
    return MAX_ERR_GENERIC;
}


t_max_err pyjs_eval(t_pyjs* x, t_symbol* s, long argc, t_atom* argv,
                    t_atom* rv)
{
    char* py_argv = atom_getsym(argv)-&gt;s_name;
    pyjs_log(x, "%s %s", s-&gt;s_name, py_argv);

    PyObject* pval = PyRun_String(py_argv, Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);

    if (pval != NULL) {
        pyjs_handle_output(x, pval, rv);
        return MAX_ERR_NONE;
    } else {
        pyjs_handle_error(x, "eval %s", py_argv);
        return MAX_ERR_GENERIC;
    }
}


</t>
<t tx="sta.20200628231456.1">t_max_err pyjs_handle_float_output(t_pyjs* x, PyObject* pfloat, t_atom* rv)
{
    t_atom atom_result[1];

    if (pfloat == NULL) {
        goto error;
    }

    if (PyFloat_Check(pfloat)) {
        float float_result = (float)PyFloat_AsDouble(pfloat);
        if (float_result == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }
        atom_setfloat(atom_result, float_result);
        atom_setobj(
            rv,
            object_new(gensym("nobox"), gensym("atomarray"), 1, atom_result));
    }
    Py_XDECREF(pfloat);
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "pyjs_handle_float_output failed");
    Py_XDECREF(pfloat);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231538.1">t_max_err pyjs_handle_long_output(t_pyjs* x, PyObject* plong, t_atom* rv)
{
    t_atom atom_result[1];

    if (plong == NULL) {
        goto error;
    }

    if (PyLong_Check(plong)) {
        long long_result = PyLong_AsLong(plong);
        if (long_result == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        atom_setlong(atom_result, long_result);
        atom_setobj(
            rv,
            object_new(gensym("nobox"), gensym("atomarray"), 1, atom_result));
    }
    Py_XDECREF(plong);
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "pyjs_handle_long_output failed");
    Py_XDECREF(plong);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231613.1">t_max_err pyjs_handle_string_output(t_pyjs* x, PyObject* pstring, t_atom* rv)
{
    t_atom atom_result[PY_MAX_ATOMS];

    if (pstring == NULL) {
        goto error;
    }

    if (PyUnicode_Check(pstring)) {
        const char* unicode_result = PyUnicode_AsUTF8(pstring);
        if (unicode_result == NULL) {
            goto error;
        }
        atom_setsym(atom_result, gensym(unicode_result));
        atom_setobj(
            rv,
            object_new(gensym("nobox"), gensym("atomarray"), 1, atom_result));
    }
    Py_XDECREF(pstring);
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "pyjs_handle_string_output failed");
    Py_XDECREF(pstring);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231643.1">t_max_err pyjs_handle_list_output(t_pyjs* x, PyObject* plist, t_atom* rv)
{
    if (plist == NULL) {
        goto error;
    }

    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            pyjs_error(x, "cannot convert py list of length 0 to atoms");
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            pyjs_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {

            if (PyFloat_Check(item)) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                pyjs_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                pyjs_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            // only for numpy int64 (not recognized by PyLong_Check)
            // if (PyNumber_Check(item)) {
            //     long long_item = PyLong_AsLong(item);
            //     if (long_item == -1) {
            //         if (PyErr_Occurred())
            //             goto error;
            //     }
            //     atom_setlong(atoms + i, long_item);
            //     pyjs_log(x, "%d long: %ld\n", i, long_item);
            //     i++;
            // }

            if (PyUnicode_Check(item)) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                atom_setsym(atoms + i, gensym(unicode_item));
                pyjs_log(x, "%d unicode: %s\n", i, unicode_item);
                i++;
            }
            Py_DECREF(item);
        }

        atom_setobj(
            rv,
            object_new(gensym("nobox"), gensym("atomarray"), (long)i, atoms));
        // atom_setobj(rv, object_new(gensym("nobox"), gensym("atomarray"), 1,
        // atoms));
        pyjs_log(x, "end iter op: %d", i);
        if (is_dynamic) {
            pyjs_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }

    Py_XDECREF(plist);
    return MAX_ERR_NONE;

error:
    pyjs_handle_error(x, "pyjs_handle_list_output failed");
    Py_XDECREF(plist);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231714.1">t_max_err pyjs_handle_dict_output(t_pyjs* x, PyObject* pdict, t_atom* rv)
{
    PyObject* pfun_co = NULL;
    PyObject* pfun = NULL;
    PyObject* pval = NULL;

    if (pdict == NULL) {
        goto error;
    }

    if (PyDict_Check(pdict)) {

        pfun_co = PyRun_String("def __py_maxmsp_out_dict(arg):\n"
                               "\tres = []\n"
                               "\tfor k,v in arg.items():\n"
                               "\t\tres.append(k)\n"
                               "\t\tres.append(':')\n"
                               "\t\tif type(v) in [list, set, tuple]:\n"
                               "\t\t\tfor i in v:\n"
                               "\t\t\t\tres.append(i)\n"
                               "\t\telse:\n"
                               "\t\t\tres.append(v)\n"
                               "\treturn res\n",
                               Py_single_input, x-&gt;p_globals, x-&gt;p_globals);

        if (pfun_co == NULL) {
            pyjs_error(x, "out_dict function code object is NULL");
            goto error;
        }

        pfun = PyDict_GetItemString(x-&gt;p_globals, "__py_maxmsp_out_dict");
        if (pfun == NULL) {
            pyjs_error(x, "retrieving out_dict func from globals failed");
            goto error;
        }

        pval = PyObject_CallFunctionObjArgs(pfun, pdict, NULL);
        if (pval == NULL) {
            pyjs_error(x, "out_dict call failed to retrieve result");
            goto error;
        }

        if (PyList_Check(pval)) { // expecting a python list
            Py_XDECREF(pfun_co);
            return pyjs_handle_list_output(x, pval, rv); // this decrefs pval
        } else {
            pyjs_error(x, "expected list output got something else");
            goto error;
        }
    }

error:
    pyjs_handle_error(x, "pyjs_handle_dict_output failed");
    Py_XDECREF(pfun_co);
    Py_XDECREF(pval);
    return MAX_ERR_GENERIC;
}
</t>
<t tx="sta.20200628231953.1">t_max_err pyjs_handle_output(t_pyjs* x, PyObject* pval, t_atom* rv)
{
    if (pval == NULL) {
        pyjs_error(x, "cannot handle NULL value");
        return MAX_ERR_GENERIC;
    }

    if (PyFloat_Check(pval)) {
        return pyjs_handle_float_output(x, pval, rv);
    }

    else if (PyLong_Check(pval)) {
        return pyjs_handle_long_output(x, pval, rv);
    }

    else if (PyUnicode_Check(pval)) {
        return pyjs_handle_string_output(x, pval, rv);
    }

    else if (PySequence_Check(pval) &amp;&amp; !PyBytes_Check(pval)
             &amp;&amp; !PyByteArray_Check(pval)) {
        return pyjs_handle_list_output(x, pval, rv);
    }

    else if (PyDict_Check(pval)) {
        return pyjs_handle_dict_output(x, pval, rv);
    }

    else if (pval == Py_None) {
        return MAX_ERR_NONE;
    }

    else {
        pyjs_error(x, "cannot handle his type of value");
        return MAX_ERR_GENERIC;
    }
}
t_max_err pyjs_code(t_pyjs* x, t_symbol* s, long argc, t_atom* argv,
</t>
<t tx="sta.20200628232027.1">// ---------------------------------------------------------------------------
// Handlers

</t>
<t tx="sta.20200628232130.1"></t>
<t tx="sta.20200628232219.1"></t>
<t tx="sta.20200628232327.1"></t>
<t tx="sta.20200628232335.1"></t>
<t tx="sta.20200701100646.1"></t>
<t tx="sta.20200724112927.1">#!/usr/bin/env python3

@others
@language python
@tabwidth -4

if __name__ == '__main__':
    p = SharedPythonBuilder()
    # p.install()
    # p.reset()
    # p.download()
    # p.build()
    # p.clean()
    # p.zip_lib()
</t>
<t tx="sta.20200724112942.1">import logging
import os
import re
import shutil
import subprocess
import sys
import zipfile
from abc import ABC, abstractmethod
from pathlib import Path

# import glob

IGNORE_ERRORS = False

DEBUG = True
if DEBUG:
    LOG_LEVEL = logging.DEBUG
else:
    LOG_LEVEL = logging.INFO

LOG_FORMAT = '%(relativeCreated)-4d %(levelname)-5s: %(name)-10s %(message)s'
logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT, stream=sys.stdout)

</t>
<t tx="sta.20200724112942.10">@property
def name_ver(self):
    return f'{self.name.lower()}{self.ver}'

</t>
<t tx="sta.20200724112942.11">@property
def url(self):
    return Path(self.url_template.format(name=self.name, 
                                    version=self.version))
</t>
<t tx="sta.20200724112942.12">@property
def name_archive(self):
    return f'{self.name_version}.tgz'

</t>
<t tx="sta.20200724112942.13">@property
def download_path(self):
    return self.project.downloads / self.name_archive

</t>
<t tx="sta.20200724112942.14">@property
def src_path(self):
    return self.project.src / self.name_version

</t>
<t tx="sta.20200724112942.15">@property
def lib_path(self):
    return self.prefix

</t>
<t tx="sta.20200724112942.16">@property
def prefix(self):
    return self.project.lib / self.name.lower()

</t>
<t tx="sta.20200724112942.17">@property
def prefix_lib(self):
    return self.prefix / 'lib'

</t>
<t tx="sta.20200724112942.18">@property
def prefix_include(self):
    return self.prefix / 'include'

</t>
<t tx="sta.20200724112942.19">@property
def prefix_bin(self):
    return self.prefix / 'bin'


</t>
<t tx="sta.20200724112942.2">class Project:
    root = Path.cwd()
    source = root.parent / 'source'
    support = root.parent.parent / 'support'
    scripts = root / 'scripts'
    patch = root / 'patch'
    targets =  root / 'targets'
    build = targets / 'build'
    downloads = build / 'downloads'
    src = build / 'src'
    lib = build / 'lib'


</t>
<t tx="sta.20200724112942.20">def libs_static_exist(self):
    for lib in self.libs_static:
        if not (self.prefix_lib / lib).exists():
            return False
    return True

</t>
<t tx="sta.20200724112942.21">def cmd(self, shellcmd, *args, **kwargs):
    os.system(shellcmd.format(*args, **kwargs))

</t>
<t tx="sta.20200724112942.22">def chdir(self, path):
    os.chdir(path)

</t>
<t tx="sta.20200724112942.23">def move(self, src, dst):
    shutil.move(src, dst)

</t>
<t tx="sta.20200724112942.24">def copytree(self, src, dst):
    shutil.copytree(src, dst)

</t>
<t tx="sta.20200724112942.25">def copyfile(self, src, dst):
    shutil.copyfile(src, dst)

</t>
<t tx="sta.20200724112942.26">def remove(self, path):
    if path.is_dir():
        shutil.rmtree(path, ignore_errors=IGNORE_ERRORS)
    else:
        path.unlink(missing_ok=True)

</t>
<t tx="sta.20200724112942.27">def reset(self):
    self.remove(self.src_path)
    self.remove(self.prefix) # aka self.prefix

</t>
<t tx="sta.20200724112942.28">def download(self):
    "download target src"

</t>
<t tx="sta.20200724112942.29">def build(self):
    "build target from src"


</t>
<t tx="sta.20200724112942.3">class Builder(ABC):
    name: str
    version: str
    url_template: str
    depends_on: []

    @others
</t>
<t tx="sta.20200724112942.30">class OSXBuilder(Builder):
    mac_dep_target = '10.13'

    @others
</t>
<t tx="sta.20200724112942.31">@property
def dylib(self):
    return f'lib{self.name.lower()}{self.ver}.dylib'        

</t>
<t tx="sta.20200724112942.32">def download(self):
    "download src"

    self.project.downloads.mkdir(parents=True, exist_ok=True)
    for dep in self.depends_on:
        dep.download()

    # download
    if not self.download_path.exists():
        self.log.info(f"downloading {self.download_path}")
        self.cmd(f'curl -L --fail {self.url} -o {self.download_path}')
 
    # unpack
    if not self.src_path.exists():
        self.log.info(f"unpacking {self.src_path}")
        self.cmd(f'tar -C {self.project.src} -xvf {self.download_path}')


</t>
<t tx="sta.20200724112942.33">class OpensslBuilder(OSXBuilder):
    name = 'openssl'
    version = '1.1.1g'
    url_template = 'https://www.openssl.org/source/{name}-{version}.tar.gz'
    depends_on = []
    libs_static = ['libssl.a', 'libcrypto.a']

    @others
</t>
<t tx="sta.20200724112942.34">def build(self):
    if not self.libs_static_exist():
        self.chdir(self.src_path)
        self.cmd(f'./config no-shared no-tests --prefix={self.prefix}')
        self.cmd('make install_sw')
        self.chdir(self.project.root)

</t>
<t tx="sta.20200724112942.35">class Bzip2Builder(OSXBuilder):
    name = 'bzip2'
    version = '1.0.8'
    url_template = 'https://sourceware.org/pub/bzip2/{name}-{version}.tar.gz'
    depends_on = []
    libs_static = ['libbz2.a']

    @others
</t>
<t tx="sta.20200724112942.36">def build(self):
    if not self.libs_static_exist():
        self.chdir(self.src_path)
        self.cmd(f'make install PREFIX={self.prefix}')
        self.chdir(self.project.root)



</t>
<t tx="sta.20200724112942.37">class XzBuilder(OSXBuilder):
    name = 'xz'
    version = '5.2.5'
    url_template = 'http://tukaani.org/xz/{name}-{version}.tar.gz'
    depends_on = []
    libs_static = ['libxz.a']

    @others
</t>
<t tx="sta.20200724112942.38">def build(self):
    if not self.libs_static_exist():
        self.chdir(self.src_path)
        self.cmd(f"""MACOSX_DEPLOYMENT_TARGET={self.mac_dep_target} \
            ./configure --disable-shared --enable-static --prefix={self.prefix}""")
        self.cmd(f'make &amp;&amp; make install')
        self.chdir(self.project.root)


</t>
<t tx="sta.20200724112942.39">class PythonBuilder(OSXBuilder):
    name = 'Python'
    version = '3.8.4'
    url_template = 'https://www.python.org/ftp/python/{version}/{name}-{version}.tgz'
    depends_on = [OpensslBuilder, Bzip2Builder, XzBuilder]
    suffix = ""
    setup_local = None
    patch = None

    @others
</t>
<t tx="sta.20200724112942.4">def __init__(self, project, version=None, depends_on=None):
    self.project = project or Project()
    self.version = version or self.version
    self.depends_on = ([B(project) for B in depends_on] if depends_on else
                       [B(project) for B in self.depends_on])
    self.log = logging.getLogger(self.__class__.__name__)

</t>
<t tx="sta.20200724112942.40">def __init__(self, project=None, version=None, depends_on=None):
    super().__init__(project, version, depends_on)

    # dependency manager attributes (revise)
    self.install_names = {}
    self.deps = []
    self.dep_list = []

# ------------------------------------------------------------------------
# python properties

</t>
<t tx="sta.20200724112942.41">@property
def static_lib(self):
    return f'lib{self.name.lower()}{self.ver}.a'

</t>
<t tx="sta.20200724112942.42">@property
def python_lib(self):
    return self.prefix_lib / self.name_ver

</t>
<t tx="sta.20200724112942.43">@property
def site_packages(self):
    return self.python_lib / 'site-packages'

</t>
<t tx="sta.20200724112942.44">@property
def lib_dynload(self):
    return self.python_lib / 'lib-dynload'    

# ------------------------------------------------------------------------
# src-level operations

</t>
<t tx="sta.20200724112942.45">def pre_process(self):
    "pre-build operations"

</t>
<t tx="sta.20200724112942.46">def post_process(self):
    "post-build operations"

</t>
<t tx="sta.20200724112942.47">def write_setup_local(self, setup_local=None):
    if not any([setup_local, self.setup_local]):
        return
    if not setup_local:
        setup_local = self.setup_local
    self.copyfile(self.project.patch / setup_local, 
              self.src_path /'Modules' / 'Setup.local')

</t>
<t tx="sta.20200724112942.48">def apply_patch(self, patch=None):
    if not any([patch, self.patch]):
        return
    if not patch:
        patch = self.patch
    self.cmd(f'patch -p1 &lt; {self.project.patch}/{patch}')

</t>
<t tx="sta.20200724112942.49">def install(self):
    self.reset()
    self.download()
    self.pre_process()
    self.build()
    self.post_process()

</t>
<t tx="sta.20200724112942.5">def __repr__(self):
    return f"&lt;{self.__class__.__name__} '{self.name}-{self.version}'&gt;"

</t>
<t tx="sta.20200724112942.50">def install_python_pkg(self):
    self.install_python()
    self.fix_python_dylib_for_pkg()


</t>
<t tx="sta.20200724112942.51">def install_python_ext(self):
    self.install_python()
    self.fix_python_dylib_for_ext()

# ------------------------------------------------------------------------
# post-processing operations

</t>
<t tx="sta.20200724112942.52">def is_valid_path(self, dep_path):
    return (dep_path == '' or 
            dep_path.startswith('/opt/local/') or 
            dep_path.startswith('/usr/local/') or 
            dep_path.startswith('/User/'))

</t>
<t tx="sta.20200724112942.53">def get_deps(self, target=None):
    if not target:
        target = self.target
    key = os.path.basename(target)
    self.install_names[key] = []
    result = subprocess.check_output(['otool', '-L', target])
    entries = [line.decode('utf-8').strip() for line in result.splitlines()]
    for entry in entries:
        match = re.match(r'\s*(\S+)\s*\(compatibility version .+\)$', entry)
        if match:
            path = match.group(1)
            (dep_path, dep_filename) = os.path.split(path)
            if self.is_valid_path(dep_path):
                if dep_path == '':
                    path = os.path.join('/usr/local/lib', dep_filename)
                dep_path, dep_filename = os.path.split(path)
                item = (path, '@rpath/' + dep_filename)
                self.install_names[key].append(item)
                if path not in self.deps:
                    self.deps.append(path)
                    self.get_deps(path)



</t>
<t tx="sta.20200724112942.54">def recursive_clean(self, name, pattern):
    self.cmd(f'find {name} | grep -E "({pattern})" | xargs rm -rf')

</t>
<t tx="sta.20200724112942.55">def clean_python_pyc(self, name):
    self.recursive_clean(name, r"__pycache__|\.pyc|\.pyo$")

</t>
<t tx="sta.20200724112942.56">def clean_python_tests(self, name):
    self.recursive_clean(name, "tests|test")

</t>
<t tx="sta.20200724112942.57">def rm_libs(self, names):
    for name in names:
        self.remove(self.python_lib / name)

</t>
<t tx="sta.20200724112942.58">def rm_exts(self, names):
    for name in names:
        self.remove(self.python_lib / 'lib-dynload' /
                    f'{name}.cpython-{self.ver_nodot}-darwin.so')

</t>
<t tx="sta.20200724112942.59">def rm_bins(self, names):
    for name in names:
        self.remove(self.prefix_bin / name)

</t>
<t tx="sta.20200724112942.6">def __iter__(self):
    for dependency in self.depends_on:
        yield dependency
        for subdependency in iter(dependency):
            yield subdependency
</t>
<t tx="sta.20200724112942.60">def clean_python_site_packages(self):
    self.remove(self.python_lib / 'site-packages')

</t>
<t tx="sta.20200724112942.61">def remove_packages(self):
    self.rm_libs([
        f'config-{self.ver}{self.suffix}-darwin',
        'idlelib',
        'lib2to3',
        'tkinter',
        'turtledemo',
        'turtle.py',
        'ctypes',
        'curses',
        'ensurepip',
        'venv',
    ])

</t>
<t tx="sta.20200724112942.62">def remove_extensions(self): pass

</t>
<t tx="sta.20200724112942.63">def remove_binaries(self):
    self.rm_bins([
        f'2to3-{self.ver}',
        f'idle{self.ver}',
        f'easy_install-{self.ver}',
        f'pip{self.ver}',
        f'pyvenv-{self.ver}',
        f'pydoc{self.ver}',
        # f'python{self.ver}{self.suffix}',
        # f'python{self.ver}-config',
    ])

</t>
<t tx="sta.20200724112942.64">def clean(self):
    self.clean_python_pyc(self.prefix)
    self.clean_python_tests(self.python_lib)
    self.clean_python_site_packages()

    for i in (self.python_lib / 'distutils' / 'command').glob('*.exe'):
        self.remove(i)

    self.remove(self.prefix_lib / 'pkgconfig')
    self.remove(self.prefix / 'share')

    self.remove_packages()
    self.remove_extensions()
    self.remove_binaries()

</t>
<t tx="sta.20200724112942.65">def zip_lib(self):
    temp_lib_dynload = self.prefix_lib / 'lib-dynload'
    temp_os_py = self.prefix_lib / 'os.py'

    self.remove(self.site_packages)
    self.lib_dynload.rename(temp_lib_dynload)
    self.copyfile(self.python_lib / 'os.py', temp_os_py)

    zip_path = self.prefix_lib  / f'python{self.ver_nodot}'
    shutil.make_archive(zip_path, 'zip', self.python_lib)

    self.remove(self.python_lib)
    self.python_lib.mkdir()
    temp_lib_dynload.rename(self.lib_dynload)
    temp_os_py.rename(self.python_lib / 'os.py')
    self.site_packages.mkdir()

    
</t>
<t tx="sta.20200724112942.66">def fix_python_dylib_for_pkg(self):
    self.chdir(self.prefix_lib)
    self.cmd(f'chmod 777 {self.dylib}')
    self.cmd(
        'install_name_tool -id '
        '@loader_path/../../../../support/{self.name}/lib/{self.dylib} '
        '${self.dylib}')
    self.chdir(self.root)

</t>
<t tx="sta.20200724112942.67">def fix_python_dylib_for_ext(self):
    self.chdir(self.prefix_lib)
    self.cmd(f'chmod 777 {self.dylib}')
    self.cmd('install_name_tool -id @loader_path/{self.dylib} {self.dylib}')
    self.chdir(self.root)

</t>
<t tx="sta.20200724112942.68">def pre_process(self):
    self.chdir(self.src_path)
    self.write_setup_local()
    self.apply_patch()
    self.chdir(self.project.root)

</t>
<t tx="sta.20200724112942.69">def post_process(self):
    self.clean()
    self.zip_lib()
    # self.fix()
    # self.sign()


</t>
<t tx="sta.20200724112942.7">@property
def ver(self):
    return  ".".join(self.version.split('.')[:2])

</t>
<t tx="sta.20200724112942.70">class StaticPythonBuilder(PythonBuilder):
    setup_local = 'setup-static-min2.local'
    patch = 'makesetup.patch'

    @others
</t>
<t tx="sta.20200724112942.71">@property
def prefix(self):
    name = f'{self.name.lower()}-static'
    return self.project.lib / name

</t>
<t tx="sta.20200724112942.72">def build(self):
    for dep in self.depends_on:
        dep.build()

    self.chdir(self.src_path)
    self.cmd(f"""\
    ./configure MACOSX_DEPLOYMENT_TARGET={self.mac_dep_target} \
        --prefix={self.prefix} \
        --without-doc-strings \
        --enable-ipv6 \
        --without-ensurepip \
        --with-lto \
        --enable-optimizations
    """)
    self.cmd('make altinstall')
    self.chdir(self.project.root)


</t>
<t tx="sta.20200724112942.73">def post_process(self):
    self.clean()
    self.zip_lib()
    self.static_lib.rename(self.prefix / self.library)



</t>
<t tx="sta.20200724112942.74">class SharedPythonBuilder(PythonBuilder):
    setup_local = 'setup-shared.local'

    @others
</t>
<t tx="sta.20200724112942.75">@property
def prefix(self):
    name = f'{self.name.lower()}-shared'
    return self.project.lib / name

</t>
<t tx="sta.20200724112942.76">def build(self):
    for dep in self.depends_on:
        dep.build()

    self.chdir(self.src_path)
    self.write_setup_local()
    self.cmd(f"""\
    ./configure MACOSX_DEPLOYMENT_TARGET={self.mac_dep_target} \
        --prefix={self.prefix} \
        --enable-shared \
        --with-openssl={self.project.lib / 'openssl'} \
        --without-doc-strings \
        --enable-ipv6 \
        --without-ensurepip \
        --with-lto \
        --enable-optimizations
    """)
    self.cmd('make altinstall')
    self.chdir(self.project.root)


</t>
<t tx="sta.20200724112942.77">def remove_extensions(self):
    self.rm_exts([
        '_tkinter',
        '_ctypes',
        '_multibytecodec',
        '_codecs_jp',
        '_codecs_hk',
        '_codecs_cn',
        '_codecs_kr',
        '_codecs_tw',
        '_codecs_iso2022',
        '_curses',
        '_curses_panel',
    ])


</t>
<t tx="sta.20200724112942.78">class FrameworkPythonBuilder(PythonBuilder):
    # setup_local = 'setup-shared.local'

    @others
</t>
<t tx="sta.20200724112942.79">@property
def prefix(self):
    return self.project.lib / 'Python.Framework'

</t>
<t tx="sta.20200724112942.8">@property
def ver_nodot(self):
    return self.ver.replace('.', '')

</t>
<t tx="sta.20200724112942.80">def build(self):
    for dep in self.depends_on:
        dep.build()

    self.chdir(self.src_path)
    self.write_setup_local()
    self.cmd(f"""\
    ./configure MACOSX_DEPLOYMENT_TARGET={self.mac_dep_target} \
        --prefix={self.prefix} \
        --enable-framework={self.project.lib} \
        --with-openssl={self.project.lib / 'openssl'} \
        --with-lto \
        --enable-optimizations
    """)
    self.cmd('make altinstall')
    self.chdir(self.project.root)


</t>
<t tx="sta.20200724112942.81">def remove_extensions(self):
    self.rm_exts([
        '_tkinter',
        '_ctypes',
        '_multibytecodec',
        '_codecs_jp',
        '_codecs_hk',
        '_codecs_cn',
        '_codecs_kr',
        '_codecs_tw',
        '_codecs_iso2022',
        '_curses',
        '_curses_panel',
    ])


</t>
<t tx="sta.20200724112942.82">class DependencyManager:
    """Aggreggates, copies dylib dependencies and fixed references.

    target: dylib to made relocatable
    frameworks_dir: where target dylib will be copied to with copied dependents
    exec_ref: back ref for executable or plugin
    """

    @others
</t>
<t tx="sta.20200724112942.83">def __init__(self, target, frameworks_dir='build', staticlibs_dir=None,
        exec_ref='@loader_path/../Frameworks'):
    self.target = target
    self.frameworks_dir = frameworks_dir
    self.staticlibs_dir = staticlibs_dir
    self.exec_ref = exec_ref
    self.install_names = {}
    self.deps = []
    self.dep_list = []

</t>
<t tx="sta.20200724112942.84">def is_valid_path(self, dep_path):
    return (dep_path == '' or 
            dep_path.startswith('/opt/local/') or 
            dep_path.startswith('/usr/local/') or 
            dep_path.startswith('/User/'))

</t>
<t tx="sta.20200724112942.85">def get_deps(self, target=None):
    if not target:
        target = self.target
    key = os.path.basename(target)
    self.install_names[key] = []
    result = subprocess.check_output(['otool', '-L', target])
    entries = [line.decode('utf-8').strip() for line in result.splitlines()]
    for entry in entries:
        match = re.match(r'\s*(\S+)\s*\(compatibility version .+\)$', entry)
        if match:
            path = match.group(1)
            (dep_path, dep_filename) = os.path.split(path)
            if self.is_valid_path(dep_path):
                if dep_path == '':
                    path = os.path.join('/usr/local/lib', dep_filename)

                dep_path, dep_filename = os.path.split(path)
                item = (path, '@rpath/' + dep_filename)
                self.install_names[key].append(item)
                if path not in self.deps:
                    self.deps.append(path)
                    self.get_deps(path)

</t>
<t tx="sta.20200724112942.86">def process_deps(self):
    for dep in self.deps:
        dep_path, dep_filename = os.path.split(dep)
        dest = os.path.join(self.frameworks_dir, dep_filename)
        self.dep_list.append([dep, '@rpath/' + dep_filename])

</t>
<t tx="sta.20200724112942.87">def copy_dylibs(self):
    if not os.path.exists(self.frameworks_dir):
        os.mkdir(self.frameworks_dir)

    # cp target to frameworks_dir
    if os.path.dirname(self.target) != self.frameworks_dir:
        dest = os.path.join(self.frameworks_dir, os.path.basename(self.target))
        shutil.copyfile(self.target, dest)
        os.chmod(dest, 0o644)
        cmdline = ['install_name_tool', '-id', self.exec_ref, dest]
        err = subprocess.call(cmdline)
        if err != 0:
            raise RuntimeError("Failed to change '{0}' '{1}'".format(dest, self.exec_ref))

    # copy the rest
    for item in self.dep_list:
        orig_path, transformed = item
        dirname, dylib = os.path.split(orig_path)

        dest = os.path.join(self.frameworks_dir, dylib)

        if not os.path.exists(dest):
            shutil.copyfile(orig_path, dest)
            os.chmod(dest, 0o644)

</t>
<t tx="sta.20200724112942.88">def change_install_names(self):
    for key in sorted(self.install_names.keys()):
        # print(key)
        # for i in self.install_names[key]:
        #     print('\t', i)
        # print()

        target = os.path.join(self.frameworks_dir, key)
        deps = self.install_names[key]
        for dep in deps:
            old, new = dep

            (old_name_path, old_name_filename) = os.path.split(old)
            if key == old_name_filename:
                cmdline = ['install_name_tool', '-id', new, target]
            else:
                cmdline = ['install_name_tool', '-change', old, new, target]

            err = subprocess.call(cmdline)
            if err != 0:
                raise RuntimeError("Failed to change '{0}' to '{1}' in '{2}".format(old, new, target))

</t>
<t tx="sta.20200724112942.89">def transform_exec(self, target):
    result = subprocess.check_output(['otool', '-L', target])
    entries = [line.decode('utf-8').strip() for line in result.splitlines()]
    for entry in entries:
        match = re.match(r'\s*(\S+)\s*\(compatibility version .+\)$', entry)
        if match:
            path = match.group(1)
            (dep_path, dep_filename) = os.path.split(path)
            if self.is_valid_path(dep_path):
                if dep_path == '':
                    path = os.path.join('/usr/local/lib', dep_filename)

                dep_path, dep_filename = os.path.split(path)

                dest = os.path.join(self.exec_ref, dep_filename)
                cmdline = ['install_name_tool', '-change', path, dest, target]
                subprocess.call(cmdline)

</t>
<t tx="sta.20200724112942.9">@property
def name_version(self):
    return f'{self.name}-{self.version}'

</t>
<t tx="sta.20200724112942.90">def copy_staticlibs(self):
    if not self.staticlibs_dir:
        raise Exception("must set 'staticlibs_dir parameter")
    for i in self.deps:
        head, tail = os.path.split(i)
        name = tail.rstrip('.dylib')
        if '.' in name:
            name = os.path.splitext(name)[0] + '.a'
        static = os.path.join(head, name)
        exists = os.path.exists(static)
        if exists:
            shutil.copyfile(static, os.path.join(self.staticlibs_dir, name))
        else:
            print("revise: not exists", static)

</t>
<t tx="sta.20200724112942.91">def process(self):
    self.get_deps()
    self.process_deps()
    self.copy_staticlibs()
    self.copy_dylibs()
    self.change_install_names()
    self.transform_exec('./eg')

</t>
<t tx="sta.20200724113554.1"></t>
<t tx="sta.20200724113615.1"></t>
<t tx="sta.20200724114055.1"></t>
</tnodes>
</leo_file>
