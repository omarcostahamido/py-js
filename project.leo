<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sta.20200602165810.1"><vh>project py</vh>
<v t="sta.20200608031946.1"><vh>startup</vh>
<v t="sta.20200608031546.1"><vh>scripts</vh>
<v t="sta.20200608031559.1"><vh>@script at_directory</vh></v>
</v>
<v t="sta.20200602165801.1"><vh>@settings</vh>
<v t="sta.20200602165801.470"><vh>Import options</vh>
<v t="sta.20200602165801.471"><vh>@bool add-context-to-headlines = False</vh></v>
</v>
</v>
</v>
<v t="sta.20200602110822.1"><vh>py</vh>
<v t="sta.20200612044656.1"><vh>@chapter not-included</vh>
<v t="sta.20200612045651.1"><vh>prototypes</vh></v>
<v t="sta.20200612043307.1"><vh>not-working</vh>
<v t="sta.20200612055834.1"><vh>api</vh>
<v t="sta.20200612055834.2"><vh>send3 (list_to_atom)</vh></v>
</v>
<v t="sta.20200612115112.1"><vh>const char* pstring_to_cstring</vh></v>
<v t="sta.20200610222640.1"><vh>t_atom* py_list_to_atom</vh></v>
<v t="sta.20200610164212.1"><vh>void py_list_to_atom2</vh></v>
<v t="sta.20200610104706.1"><vh>void py_handle_list_output2</vh></v>
</v>
<v t="sta.20200612044825.1"><vh>working</vh>
<v t="sta.20200612045044.1"><vh>api</vh>
<v t="sta.20200612044941.1"><vh>send2</vh></v>
</v>
<v t="sta.20200607084300.1"><vh>void py_exec2</vh></v>
<v t="sta.20200607084251.1"><vh>void py_eval2</vh></v>
<v t="sta.20200602120251.26"><vh>void py_globex</vh></v>
<v t="sta.20200608043930.1"><vh>void py_lookup</vh></v>
<v t="sta.20200612051513.1"><vh>void py_handle_output</vh></v>
<v t="sta.20200605120205.1"><vh>void py_locatefile</vh></v>
<v t="sta.20200610070057.1"><vh>void py_send_from_seq</vh></v>
<v t="sta.20200612114958.1"><vh>float pfloat_to_cfloat</vh></v>
<v t="sta.20200612115000.1"><vh>long plong_to_clong</vh></v>
<v t="sta.20200612065729.1"><vh>files</vh>
<v t="sta.20200612065752.1"><vh>@@auto globex.h</vh></v>
<v t="sta.20200612065639.1"><vh>@@auto globex.c</vh>
<v t="sta.20200612065813.1"><vh>static PyMethodDef</vh></v>
<v t="sta.20200612065813.2"><vh>static PyModuleDef</vh></v>
<v t="sta.20200612065813.3"><vh>int _add_map_to_module</vh></v>
</v>
</v>
</v>
</v>
<v t="sta.20200602164905.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20200602151837.1"><vh>@chapter notes</vh>
<v t="sta.20200602154708.1"><vh>@auto structure.txt</vh></v>
<v t="sta.20200602151900.1"><vh>@auto-md max-c-api.md</vh></v>
<v t="sta.20200602154130.1"><vh>@auto-md python-c-api.md</vh></v>
<v t="sta.20200602154301.1"><vh>@auto-md type-translation.md</vh></v>
<v t="sta.20200602154345.1"><vh>@auto-md repl.md</vh></v>
<v t="sta.20200602154429.1"><vh>@auto-md cython.md</vh></v>
<v t="sta.20200602154452.1"><vh>@auto-md packaging.md</vh></v>
<v t="sta.20200602154517.1"><vh>@auto-md scripting-tips.md</vh></v>
<v t="sta.20200602154626.1"><vh>@auto-md testing.md</vh></v>
</v>
<v t="sta.20200602164507.1"><vh>@chapter tests</vh>
<v t="sta.20200602164529.1"><vh>@clean test_translate.c</vh>
<v t="sta.20200602165143.1"><vh>declarations</vh></v>
<v t="sta.20200602165143.2"><vh>int main</vh></v>
<v t="sta.20200602165143.3"><vh>void handle_py_error</vh></v>
<v t="sta.20200602165143.4"><vh>int py_import</vh></v>
<v t="sta.20200602165143.5"><vh>int py_exec</vh></v>
<v t="sta.20200602165143.6"><vh>int py_execfile</vh></v>
<v t="sta.20200602165143.7"><vh>int py_run</vh></v>
<v t="sta.20200602165143.8"><vh>const char* py_eval_unicode</vh></v>
<v t="sta.20200602165301.1"><vh>long* py_eval_long_seq</vh></v>
<v t="sta.20200602165143.9"><vh>float* py_eval_float_seq</vh></v>
</v>
<v t="sta.20200602170210.1"><vh>@clean test_py.c</vh>
<v t="sta.20200602170222.1"><vh>declarations</vh></v>
<v t="sta.20200602170222.2"><vh>int main</vh></v>
<v t="sta.20200602170222.3"><vh>void py_import</vh></v>
<v t="sta.20200602170222.4"><vh>void py_run</vh></v>
<v t="sta.20200602170222.5"><vh>void py_execfile</vh></v>
<v t="sta.20200602170222.6"><vh>void py_exec</vh></v>
<v t="sta.20200602170222.7"><vh>void py_eval</vh></v>
</v>
<v t="sta.20200602170255.1"><vh>@clean test_py2.c</vh>
<v t="sta.20200602170336.1"><vh>typedef struct</vh></v>
<v t="sta.20200602170336.2"><vh>int main</vh></v>
<v t="sta.20200602170336.3"><vh>void handle_py_error</vh></v>
<v t="sta.20200602170336.4"><vh>void py_import</vh></v>
<v t="sta.20200602170336.5"><vh>void py_eval</vh></v>
<v t="sta.20200602170336.6"><vh>void py_exec</vh></v>
<v t="sta.20200602170336.7"><vh>void py_execfile</vh></v>
<v t="sta.20200602170336.8"><vh>void py_assign</vh></v>
<v t="sta.20200602170336.9"><vh>void py_anything</vh></v>
</v>
<v t="sta.20200602170358.1"><vh>@clean test_goto.c</vh>
<v t="sta.20200602170611.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170405.1"><vh>@clean test_args.c</vh>
<v t="sta.20200602170608.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170419.1"><vh>@clean test_arg2.c</vh>
<v t="sta.20200602170604.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170439.1"><vh>@clean test_string.c</vh>
<v t="sta.20200602170602.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170448.1"><vh>@clean test_print.c</vh>
<v t="sta.20200602170558.1"><vh>void printf2</vh></v>
<v t="sta.20200602170558.2"><vh>void sprintf2</vh></v>
<v t="sta.20200602170558.3"><vh>void test_sprintf2</vh></v>
<v t="sta.20200602170558.4"><vh>int main</vh></v>
</v>
<v t="sta.20200602170456.1"><vh>@clean test_minim.c</vh>
<v t="sta.20200602170556.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170513.1"><vh>@clean test_call.c</vh>
<v t="sta.20200602170550.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602174033.1"><vh>@clean test_interactive.c</vh>
<v t="sta.20200602174134.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170502.1"><vh>@clean test_demo.py</vh>
<v t="sta.20200602170553.1"><vh>Declarations</vh></v>
<v t="sta.20200602170553.2"><vh>module</vh></v>
<v t="sta.20200602170553.3"><vh>expression</vh></v>
<v t="sta.20200602170553.4"><vh>test_import</vh></v>
<v t="sta.20200602170553.5"><vh>test_import_error</vh></v>
<v t="sta.20200602170553.6"><vh>test_eval</vh></v>
</v>
</v>
<v t="sta.20200602110836.1"><vh>@chapter src</vh>
<v t="sta.20200602145459.1"><vh>@clean py.h</vh>
<v t="sta.20200602150733.1"><vh>includes</vh></v>
<v t="sta.20200602150814.1"><vh>constants</vh></v>
<v t="sta.20200602145807.1"><vh>global variables</vh></v>
<v t="sta.20200602145517.1"><vh>object types</vh></v>
<v t="sta.20200602150052.1"><vh>function types</vh></v>
<v t="sta.20200602150129.1"><vh>enums</vh></v>
<v t="sta.20200602150250.1"><vh>macros</vh></v>
<v t="sta.20200602150324.1"><vh>methods</vh></v>
</v>
<v t="sta.20200602110841.1"><vh>@clean py.c</vh>
<v t="sta.20200602131126.1"><vh>includes</vh></v>
<v t="sta.20200602131131.1"><vh>globals</vh></v>
<v t="sta.20200602120540.1"><vh>helpers</vh>
<v t="sta.20200602120251.4"><vh>void py_log</vh></v>
<v t="sta.20200602120251.5"><vh>void py_error</vh></v>
<v t="sta.20200615052024.1"><vh>void py_init_builtins</vh></v>
<v t="sta.20200611235620.1"><vh>t_hashtab* get_global_registry</vh></v>
<v t="sta.20200615052054.1"><vh>void py_locate_path_from_symbol</vh></v>
</v>
<v t="sta.20200602120514.1"><vh>init &amp; free</vh>
<v t="sta.20200602120251.3"><vh>void ext_main</vh></v>
<v t="sta.20200602120251.7"><vh>void* py_new</vh></v>
<v t="sta.20200602120251.8"><vh>void py_init</vh></v>
<v t="sta.20200602120251.9"><vh>void py_free</vh></v>
</v>
<v t="sta.20200602121012.1"><vh>information</vh>
<v t="sta.20200602120251.10"><vh>void py_assist</vh></v>
<v t="sta.20200602122617.1"><vh>void py_count</vh></v>
</v>
<v t="sta.20200602122226.1"><vh>testing</vh>
<v t="sta.20200602122244.1"><vh>void py_bang</vh></v>
</v>
<v t="sta.20200608042323.1"><vh>common handlers</vh>
<v t="sta.20200602120251.13"><vh>void py_handle_error</vh></v>
<v t="sta.20200610181828.1"><vh>void py_handle_float_output</vh></v>
<v t="sta.20200610104609.1"><vh>void py_handle_long_output</vh></v>
<v t="sta.20200610105537.1"><vh>void py_handle_string_output</vh></v>
<v t="sta.20200610231913.1"><vh>void py_handle_list_output</vh></v>
<v t="sta.20200606044751.1"><vh>void py_handle_output</vh></v>
</v>
<v t="sta.20200610100240.1"><vh>translators</vh>
<v t="sta.20200610100158.1"><vh>PyObject* py_atom_to_list</vh></v>
</v>
<v t="sta.20200602120318.1"><vh>core</vh>
<v t="sta.20200602120251.20"><vh>void py_import</vh></v>
<v t="sta.20200602120251.21"><vh>void py_eval</vh></v>
<v t="sta.20200602120251.22"><vh>void py_exec</vh></v>
<v t="sta.20200602120251.23"><vh>void py_execfile</vh></v>
</v>
<v t="sta.20200602120740.1"><vh>extra</vh>
<v t="sta.20200602120251.25"><vh>void py_call</vh></v>
<v t="sta.20200602120251.24"><vh>void py_assign</vh></v>
<v t="sta.20200605120324.1"><vh>void py_code</vh></v>
</v>
<v t="sta.20200606073716.1"><vh>interobject</vh>
<v t="sta.20200602120251.11"><vh>void py_scan</vh></v>
<v t="sta.20200603072826.1"><vh>long py_scan_callback</vh></v>
<v t="sta.20200602120251.12"><vh>void py_send</vh></v>
</v>
<v t="sta.20200602120447.1"><vh>editor</vh>
<v t="sta.20200602120251.14"><vh>void py_dblclick</vh></v>
<v t="sta.20200602120251.15"><vh>void py_read</vh></v>
<v t="sta.20200602120251.16"><vh>void py_doread</vh></v>
<v t="sta.20200602120251.17"><vh>void py_edclose</vh></v>
<v t="sta.20200602120251.18"><vh>void py_edsave</vh></v>
<v t="sta.20200602120251.19"><vh>void py_load</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sta.20200602110822.1"></t>
<t tx="sta.20200602110836.1">@path source/py</t>
<t tx="sta.20200602110841.1">// py.c

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602120251.10">void py_assist(t_py* x, void* b, long m, long a, char* s)
{
    if (m == ASSIST_INLET) { // inlet
        sprintf(s, "I am inlet %ld", a);
    } else { // outlet
        sprintf(s, "I am outlet %ld", a);
    }
}
</t>
<t tx="sta.20200602120251.11">void py_scan(t_py* x)
{
    long result = 0;

    hashtab_clear(py_global_registry);

    if (x-&gt;p_patcher == NULL) {
        post("p_patcher == NULL");
    } else {
        post("p_patcher != NULL");
    }

    if (x-&gt;p_patcher) {
        object_method(x-&gt;p_patcher, gensym("iterate"),
                      (method)py_scan_callback, x, PI_DEEP | PI_WANTBOX,
                      &amp;result);
    } else {
        py_error(x, "scan failed");
    }
}

</t>
<t tx="sta.20200602120251.12">void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    // see:
    // https://cycling74.com/forums/error-handling-with-object_method_typed
    t_object* obj = NULL;
    char* obj_name = NULL;
    t_symbol* msg_sym = NULL;
    t_max_err err = NULL;

    if (argc &lt; 2) {
        py_error(x, "need at least 2 args to send msg");
        goto error;
    }

    if ((argv + 0)-&gt;a_type != A_SYM) {
        py_error(
            x, "1st arg of send needs to be a symbol name of receiver object");
        goto error;
    }

    // argv+0 is the object name to send to
    obj_name = atom_getsym(argv)-&gt;s_name;
    if (obj_name == NULL) {
        goto error;
    }

    // if registry is empty, scan it
    if (hashtab_getsize(py_global_registry) == 0) {
        py_scan(x);
    }

    // // lookup name in registry
    err = hashtab_lookup(py_global_registry, gensym(obj_name), &amp;obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found in the registry");
        goto error;
    }

    // atom after the name of the receiver
    switch ((argv + 1)-&gt;a_type) {
    case A_SYM: {
        msg_sym = atom_getsym(argv + 1);
        if (msg_sym == NULL) { // should check type here
            goto error;
        }
        // address the minimum case: e.g a bang
        if (argc - 2 == 0) { //
            argc = 0;
            argv = NULL;
        } else {
            argc = argc - 2;
            argv = argv + 2;
        }
        break;
    }
    case A_FLOAT: {
        msg_sym = gensym("float");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        argv = argv + 1;

        break;
    }
    case A_LONG: {
        msg_sym = gensym("int");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        argv = argv + 1;

        break;
    }
    default:
        py_log(x, "cannot process unknown type");
        break;
    }

    // methods to get method type
    t_messlist* messlist = object_mess((t_object*)obj, msg_sym);
    if (messlist) {
        post("messlist-&gt;m_sym  (name of msg): %s", messlist-&gt;m_sym-&gt;s_name);
        post("messlist-&gt;m_type (type of msg): %d", messlist-&gt;m_type[0]);
    }

    err = object_method_typed(obj, msg_sym, argc, argv, NULL);
    if (err) {
        py_error(x, "failed to send a message to object %s", obj_name);
        goto error;
    }

    // success
    return;

error:
    py_error(x, "send failed");
    return;
}

</t>
<t tx="sta.20200602120251.13">void py_handle_error(t_py* x, char* fmt, ...)
{
    if (PyErr_Occurred()) {

        // build custom msg
        char msg[50];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        // get error info
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        PyErr_NormalizeException(&amp;ptype, &amp;pvalue, &amp;ptraceback);

        // PyObject* ptype_pstr = PyObject_Repr(ptype);
        // const char* ptype_str = PyUnicode_AsUTF8(ptype_pstr);
        Py_XDECREF(ptype);
        // Py_XDECREF(ptype_pstr);

        PyObject* pvalue_pstr = PyObject_Repr(pvalue);
        const char* pvalue_str = PyUnicode_AsUTF8(pvalue_pstr);
        Py_XDECREF(pvalue);
        Py_XDECREF(pvalue_pstr);

        Py_XDECREF(ptraceback);

        error("[py %s] &lt;- (%s): %s", x-&gt;p_name-&gt;s_name, msg, pvalue_str);
    }
}
</t>
<t tx="sta.20200602120251.14">void py_dblclick(t_py* x)
{
    if (x-&gt;p_code_editor)
        object_attr_setchar(x-&gt;p_code_editor, gensym("visible"), 1);
    else {
        x-&gt;p_code_editor = object_new(CLASS_NOBOX, gensym("jed"), x, 0);
        object_method(x-&gt;p_code_editor, gensym("settext"), *x-&gt;p_code,
                      gensym("utf-8"));
        object_attr_setchar(x-&gt;p_code_editor, gensym("scratch"), 1);
        object_attr_setsym(x-&gt;p_code_editor, gensym("title"),
                           gensym("py-editor"));
    }
}

</t>
<t tx="sta.20200602120251.15">void py_read(t_py* x, t_symbol* s)
{
    defer((t_object*)x, (method)py_doread, s, 0, NULL);
}

</t>
<t tx="sta.20200602120251.16">void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    t_max_err err;
    t_filehandle fh;

    py_locate_path_from_symbol(x, s);
    err = path_opensysfile(x-&gt;p_code_filename, x-&gt;p_code_path, &amp;fh, READ_PERM);
    if (!err) {
        sysfile_readtextfile(fh, x-&gt;p_code, 0,
                             TEXT_LB_UNIX | TEXT_NULL_TERMINATE);
        sysfile_close(fh);
        x-&gt;p_code_size = sysmem_handlesize(x-&gt;p_code);
    }
}

// void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv)
// {
//     t_fourcc filetype = FOUR_CHAR_CODE('TEXT'), outtype;
//     char filename[MAX_PATH_CHARS];
//     char pathname[MAX_PATH_CHARS];
//     short path;
//     t_max_err err;
//     t_filehandle fh;

//     if (s == gensym("")) { // if no arg supplied ask for file
//         filename[0] = 0;

//         if (open_dialog(filename, &amp;path, &amp;outtype, &amp;filetype, 1))
//             // non-zero: cancelled
//             return;

//     } else {
//         // must copy symbol before calling locatefile_extended
//         strcpy(filename, s-&gt;s_name);
//         if (locatefile_extended(filename, &amp;path, &amp;outtype, &amp;filetype, 1)) {
//             // nozero: not found
//             py_error(x, "can't find file %s", s-&gt;s_name);
//             return;
//         } else {
//             err = path_toabsolutesystempath(path, filename, pathname);
//         }

//         // success
//         // set attribute from pathname symbol
//         x-&gt;p_code_filepath = gensym(pathname);
//         err = path_opensysfile(filename, path, &amp;fh, READ_PERM);
//         if (!err) {
//             sysfile_readtextfile(fh, x-&gt;p_code, 0,
//                                  TEXT_LB_UNIX | TEXT_NULL_TERMINATE);
//             sysfile_close(fh);
//             x-&gt;p_code_size = sysmem_handlesize(x-&gt;p_code);
//         }
//     }
// }

</t>
<t tx="sta.20200602120251.17">void py_edclose(t_py* x, char** text, long size)
{
    if (x-&gt;p_code)
        sysmem_freehandle(x-&gt;p_code);

    x-&gt;p_code = sysmem_newhandleclear(size + 1);
    sysmem_copyptr((char*)*text, *x-&gt;p_code, size);
    x-&gt;p_code_size = size + 1;
    x-&gt;p_code_editor = NULL;
}

</t>
<t tx="sta.20200602120251.18">void py_edsave(t_py* x, char** text, long size)
{
    PyObject* pval = NULL;

    if (text == NULL) {
        goto error;
    }

    pval = PyRun_String(*text, Py_file_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);
    return;

error:
    py_handle_error(x, "edclose-exec %s", x-&gt;p_code_filepath-&gt;s_name);
    Py_XDECREF(pval);
}

</t>
<t tx="sta.20200602120251.19">void py_load(t_py* x, t_symbol* s)
{
    if (s == gensym("")) {
        if (x-&gt;p_code_filepath != gensym("")) {
            py_read(x, x-&gt;p_code_filepath);
            py_execfile(x, x-&gt;p_code_filepath);
            return;
        }
    } else {
        py_read(x, s);
        py_execfile(x, s);
    }
}
</t>
<t tx="sta.20200602120251.20">void py_import(t_py* x, t_symbol* s)
{
    PyObject* x_module = NULL;

    if (s != gensym("")) {
        x_module = PyImport_ImportModule(s-&gt;s_name);
        // x_module borrrowed ref
        if (x_module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, s-&gt;s_name, x_module);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "imported: %s", s-&gt;s_name);
    }
    return;

error:
    py_handle_error(x, "import %s", s-&gt;s_name);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.21">void py_eval(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* py_argv = atom_getsym(argv)-&gt;s_name;
    py_log(x, "%s %s", s-&gt;s_name, py_argv);

    PyObject* pval = PyRun_String(py_argv, Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);

    if (pval != NULL) {
        py_handle_output(x, pval);
        return;
    } else {
        py_handle_error(x, "eval %s", py_argv);
    }
}

</t>
<t tx="sta.20200602120251.22">void py_exec(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* py_argv = NULL;
    PyObject* pval = NULL;

    py_argv = atom_getsym(argv)-&gt;s_name;
    if (py_argv == NULL) {
        goto error;
    }

    pval = PyRun_String(py_argv, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    outlet_bang(x-&gt;p_outlet_right);

    // success cleanup
    Py_DECREF(pval);
    py_log(x, "exec %s", py_argv);
    return;

error:
    py_handle_error(x, "exec %s", py_argv);
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.23">void py_execfile(t_py* x, t_symbol* s)
{

    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (s != gensym("")) {
        // set x-&gt;p_code_filepath
        py_locate_path_from_symbol(x, s);
    }

    if (s == gensym("") || x-&gt;p_code_filepath == gensym("")) {
        py_error(x, "could not set filepath");
        goto error;
    } 

    // assume x-&gt;p_code_filepath has be been set without errors

    py_log(x, "pathname: %s",  x-&gt;p_code_filepath-&gt;s_name);
    fhandle = fopen(x-&gt;p_code_filepath-&gt;s_name, "r+");

    if (fhandle == NULL) {
        py_error(x, "could not open file");
        goto error;
    }

    pval = PyRun_File(fhandle,  x-&gt;p_code_filepath-&gt;s_name, Py_file_input, 
                      x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "execfile");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.24">void py_assign(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* varname = NULL;
    PyObject* list = NULL;

    if (s != gensym(""))
        py_log(x, "s: %s", s-&gt;s_name);

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        varname = atom_getsym(argv)-&gt;s_name;
        py_log(x, "varname: %s", varname);
    }

    list = py_atom_to_list(x, argc, argv, 1);
    if (list == NULL) {
        py_error(x, "atom to py list conversion failed");
        goto error;
    }

    if (PyList_Size(list) != argc - 1) {
        py_error(x, "PyList_Size(list) != argc - 1");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(list));
    }

    // finally, assign list to varname in object namespace
    py_log(x, "setting %s to list in namespace", varname);
    int res = PyDict_SetItemString(x-&gt;p_globals, varname, list);
    if (res != 0) {
        py_error(x, "assign varname to list failed");
        goto error;
    }
    // Py_XDECREF(list); // causes a crash
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "assign %s", s-&gt;s_name);
    Py_XDECREF(list);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.25">void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* callable_name = NULL;
    PyObject* py_argslist = NULL;
    PyObject* pval = NULL;
    PyObject* py_callable = NULL;
    // python list
    PyObject* py_args = NULL; // python tuple

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        callable_name = atom_getsym(argv)-&gt;s_name;
        py_log(x, "callable_name: %s", callable_name);
    }

    py_callable = PyRun_String(callable_name, Py_eval_input, x-&gt;p_globals,
                               x-&gt;p_globals);
    if (py_callable == NULL) {
        py_error(x, "could not evaluate %s", callable_name);
        goto error;
    }

    py_argslist = py_atom_to_list(x, argc, argv, 1);
    if (py_argslist == NULL) {
        py_error(x, "atom to py list conversion failed");
        goto error;
    }

    py_log(x, "length of argc:%ld list: %d", argc, PyList_Size(py_argslist));

    // convert py_args to tuple
    py_args = PyList_AsTuple(py_argslist);
    if (py_args == NULL) {
        py_error(x, "unable to convert args list to tuple");
        goto error;
    }

    // pval = PyObject_Call(py_callable, py_args, NULL);
    pval = PyObject_CallObject(py_callable, py_args);
    if (!PyErr_ExceptionMatches(PyExc_TypeError)) {
        if (pval == NULL) {
            py_error(x, "unable to apply callable(*args)");
            goto error;
        }
        goto handle_output;
    }
    PyErr_Clear();

    pval = PyObject_CallFunctionObjArgs(py_callable, py_argslist, NULL);
    if (pval == NULL) {
        py_error(x, "could not retrieve result of callable(list)");
        goto error;
    }
    goto handle_output; // this is redundant but safe in case code is added

handle_output:

    py_handle_output(x, pval);
    // success cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    py_log(x, "END %s", s-&gt;s_name);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:

    py_handle_error(x, "anything %s", s-&gt;s_name);
    // cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.26">/*
needs the following above Py_Initialize;

if (PyImport_AppendInittab("globex", PyInit_globex) == -1) {
    py_error(x, "could not add globex to builtin modules table");
}

*/


void py_globex(t_py* x, long n)
{
    PyObject* globex_mod = NULL;

    globex_mod = PyImport_ImportModule("globex"); // x_module borrrowed ref
    if (globex_mod == NULL) {
        goto error;
    }

    PyDict_SetItemString(x-&gt;p_globals, "globex", globex_mod);

    PyObject* globex_dict = PyModule_GetDict(globex_mod);

    if (PyDict_SetItemString(globex_dict, NAME_INT, PyLong_FromLong(n))
        == -1) {
        py_error(x, "cannot set long to NAME_INT");
        goto error;
    }

    outlet_bang(x-&gt;p_outlet_right);
    py_log(x, "globex import and globex.INT = %ld", n);
    return;
error:
    py_handle_error(x, "globex %ld", n);
    outlet_bang(x-&gt;p_outlet_middle);
}
</t>
<t tx="sta.20200602120251.3">void ext_main(void* r)
{
    t_class* c;

    c = class_new("py", (method)py_new, (method)py_free, (long)sizeof(t_py),
                  0L, A_GIMME, 0);

    // object methods
    //------------------------------------------------------------------------
    // clang-format off
     

    // testing
    class_addmethod(c, (method)py_bang,       "bang",       0);

    // core
    class_addmethod(c, (method)py_import,     "import",     A_SYM,    0);
    class_addmethod(c, (method)py_eval,       "eval",       A_GIMME,  0);
    class_addmethod(c, (method)py_exec,       "exec",       A_GIMME,  0);
    class_addmethod(c, (method)py_execfile,   "execfile",   A_DEFSYM, 0);

    // core extra
    class_addmethod(c, (method)py_assign,     "assign",     A_GIMME,  0);
    class_addmethod(c, (method)py_call,       "call",       A_GIMME,  0);
    class_addmethod(c, (method)py_code,       "code",       A_GIMME,  0);
    
    // meta
    class_addmethod(c, (method)py_assist,     "assist",     A_CANT, 0);
    class_addmethod(c, (method)py_count,      "count",      A_NOTHING, 0);

    // interobject
    class_addmethod(c, (method)py_scan,       "scan",       A_NOTHING, 0);
    class_addmethod(c, (method)py_send,       "send",       A_GIMME,   0);

    // code editor
    class_addmethod(c, (method)py_read,       "read",       A_DEFSYM, 0);
    class_addmethod(c, (method)py_dblclick,   "dblclick",   A_CANT,   0);
    class_addmethod(c, (method)py_edclose,    "edclose",    A_CANT,   0);
    class_addmethod(c, (method)py_edsave,     "edsave",     A_CANT,   0);
    class_addmethod(c, (method)py_load,       "load",       A_DEFSYM, 0);

    // object attributes
    //------------------------------------------------------------------------

    CLASS_ATTR_LABEL(c, "name", 0,  "unique object id");
    CLASS_ATTR_SYM(c,   "name", 0,   t_py, p_name);
    CLASS_ATTR_BASIC(c, "name", 0);
    // CLASS_ATTR_INVISIBLE(c, "name", 0);

    CLASS_ATTR_LABEL(c,  "debug", 0,  "debug log to console");
    CLASS_ATTR_CHAR(c,   "debug", 0,  t_py, p_debug);
    CLASS_ATTR_STYLE(c,  "debug", 0, "onoff");
    CLASS_ATTR_BASIC(c,  "debug", 0);
    CLASS_ATTR_SAVE(c,   "debug", 0);

    CLASS_ATTR_LABEL(c,  "file", 0,  "default python script");
    CLASS_ATTR_SYM(c,    "file", 0,   t_py,  p_code_filepath);
    CLASS_ATTR_STYLE(c,  "file", 0,   "file");
    CLASS_ATTR_BASIC(c,  "file", 0);
    CLASS_ATTR_SAVE(c,   "file", 0);

    CLASS_ATTR_LABEL(c,  "autoload", 0,  "autoload default python script");
    CLASS_ATTR_CHAR(c,   "autoload", 0,  t_py, p_autoload);
    CLASS_ATTR_STYLE(c,  "autoload", 0, "onoff");
    CLASS_ATTR_BASIC(c,  "autoload", 0);
    CLASS_ATTR_SAVE(c,   "autoload", 0);


    CLASS_ATTR_LABEL(c,  "pythonpath", 0,  "per-object pythonpath");
    CLASS_ATTR_SYM(c,    "pythonpath", 0,  t_py, p_pythonpath);
    CLASS_ATTR_STYLE(c,  "pythonpath", 0,  "file");
    CLASS_ATTR_BASIC(c,  "pythonpath", 0);
    CLASS_ATTR_SAVE(c,   "pythonpath", 0);

    CLASS_ATTR_ORDER(c,  "name",        0,  "1");
    CLASS_ATTR_ORDER(c,  "file",        0,  "2");
    CLASS_ATTR_ORDER(c,  "autoload",    0,  "3");
    CLASS_ATTR_ORDER(c,  "pythonpath",  0,  "4");
    CLASS_ATTR_ORDER(c,  "debug",       0,  "5");

    // clang-format on
    //------------------------------------------------------------------------

    class_register(CLASS_BOX, c);

    /* for js registration (can't be both box and nobox) */
    // c-&gt;c_flags = CLASS_FLAG_POLYGLOT;
    // class_register(CLASS_NOBOX, c);

    py_class = c;
}

</t>
<t tx="sta.20200602120251.4">void py_log(t_py* x, char* fmt, ...)
{
    if (x-&gt;p_debug) {
        char msg[PY_MAX_LOG_CHAR];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        post("[py %s]: %s", x-&gt;p_name-&gt;s_name, msg);
    }
}

</t>
<t tx="sta.20200602120251.5">void py_error(t_py* x, char* fmt, ...)
{
    char msg[PY_MAX_ERR_CHAR];

    va_list va;
    va_start(va, fmt);
    vsprintf(msg, fmt, va);
    va_end(va);

    error("[py %s]: %s", x-&gt;p_name-&gt;s_name, msg);
}

</t>
<t tx="sta.20200602120251.7">void* py_new(t_symbol* s, long argc, t_atom* argv)
{
    t_py* x = NULL;

    x = (t_py*)object_alloc(py_class);

    if (x) {

        if (py_global_obj_count == 0) {
            // first py obj is called '__main__'
            x-&gt;p_name = gensym("__main__");
        } else {
            x-&gt;p_name = symbol_unique();
        }
        // x-&gt;p_name = symbol_unique();

        // communication
        x-&gt;p_patcher = NULL;
        x-&gt;p_box = NULL;

        // python-related
        x-&gt;p_pythonpath = gensym("");
        x-&gt;p_debug = 1;

        // text editor
        x-&gt;p_code = sysmem_newhandle(0);
        x-&gt;p_code_size = 0;
        x-&gt;p_code_editor = NULL;
        x-&gt;p_code_filetype = FOUR_CHAR_CODE('TEXT');
        x-&gt;p_code_outtype = 0;
        // x-&gt;p_code_filename[MAX_PATH_CHARS];
        // x-&gt;p_code_pathname[MAX_PATH_CHARS];
        // short p_code_path;
        x-&gt;p_code_filepath = gensym("");

        // create inlet(s)
        // create outlet(s)
        x-&gt;p_outlet_right = outlet_new(x, NULL);
        x-&gt;p_outlet_middle = outlet_new(x, NULL);
        x-&gt;p_outlet_left = outlet_new(x, NULL);

        // process @arg attributes
        attr_args_process(x, argc, argv);

        object_obex_lookup(x, gensym("#P"), (t_patcher**)&amp;x-&gt;p_patcher);
        if (x-&gt;p_patcher == NULL)
            error("patcher object not created.");

        object_obex_lookup(x, gensym("#B"), (t_box**)&amp;x-&gt;p_box);
        if (x-&gt;p_box == NULL)
            error("patcher object not created.");

        // create scripting name
        t_max_err err = jbox_set_varname(x-&gt;p_box, x-&gt;p_name);
        if (err != MAX_ERR_NONE) {
            error("could not set scripting name");
        }

        // python init
        py_init(x);

        py_log(x, "object created");
        for (int i = 0; i &lt; argc; i++) {
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            post("argc: %d  argv: %s", i, atom_getsym(argv + i)-&gt;s_name);
        }
    }

    return (x);
}

</t>
<t tx="sta.20200602120251.8">void py_init(t_py* x)
{
    // wchar_t *program;

    // program = Py_DecodeLocale(argv[0], NULL);
    // program = Py_DecodeLocale("py", NULL);
    // if (program == NULL) {
    //     exit(1);
    // }

    /* Add the cythonized 'api' built-in module, before Py_Initialize */
    if (PyImport_AppendInittab("api", PyInit_api) == -1) {
        py_error(x, "could not add api to builtin modules table");
    }

    // Py_SetProgramName(program);

    Py_Initialize();

    // python init
    PyObject* main_mod = PyImport_AddModule(x-&gt;p_name-&gt;s_name); // borrowed
    x-&gt;p_globals = PyModule_GetDict(main_mod); // borrowed reference
    py_init_builtins(x); // does this have to be a separate function?

    // register the object
    object_register(CLASS_BOX, x-&gt;p_name, x);

    // increment global object counter
    py_global_obj_count++;

    if (py_global_obj_count == 1) {
        // if first py object create the py_global_registry;
        py_global_registry = (t_hashtab*)hashtab_new(0);
        hashtab_flags(py_global_registry, OBJ_FLAG_REF);
    }
}

</t>
<t tx="sta.20200602120251.9">void py_free(t_py* x)
{
    // code editor cleanup
    object_free(x-&gt;p_code_editor);
    if (x-&gt;p_code)
        sysmem_freehandle(x-&gt;p_code);

    Py_XDECREF(x-&gt;p_globals);
    // python objects cleanup
    py_log(x, "will be deleted");
    py_global_obj_count--;
    if (py_global_obj_count == 0) {
        /* WARNING: don't call x here or max will crash */
        hashtab_chuck(py_global_registry);

        post("last py obj freed -&gt; finalizing py mem / interpreter.");
        // PyMem_RawFree(program);
        Py_FinalizeEx();
    }
}

</t>
<t tx="sta.20200602120318.1">/*--------------------------------------------------------------------------*/
// CORE

</t>
<t tx="sta.20200602120447.1">/*--------------------------------------------------------------------------*/
// EDITOR

</t>
<t tx="sta.20200602120514.1">/*--------------------------------------------------------------------------*/
// INIT &amp; FREE

</t>
<t tx="sta.20200602120540.1">/*--------------------------------------------------------------------------*/
// HELPERS

// WARNING: if PY_MAX_LOG_CHAR (which defines PY_MAX_ERR_CHAR) is too low
// long log or err messages will crash 

</t>
<t tx="sta.20200602120740.1">/*--------------------------------------------------------------------------*/
// EXTRA

</t>
<t tx="sta.20200602121012.1">/*--------------------------------------------------------------------------*/
// DOCUMENTATION

</t>
<t tx="sta.20200602122226.1">/*--------------------------------------------------------------------------*/
// TESTING
</t>
<t tx="sta.20200602122244.1">
void py_bang(t_py* x)
{
    // just a basic bang out the left outlet method
    outlet_bang(x-&gt;p_outlet_left);
}

</t>
<t tx="sta.20200602122617.1">
void py_count(t_py* x) { outlet_int(x-&gt;p_outlet_left, py_global_obj_count); }
</t>
<t tx="sta.20200602131126.1">/*--------------------------------------------------------------------------*/
// INCLUDES

/* py external api */
#include "py.h"

/* max/msp api */
#include "api.h"

</t>
<t tx="sta.20200602131131.1">/*--------------------------------------------------------------------------*/
// GLOBALS

t_class* py_class; // global pointer to object class

static int py_global_obj_count = 0; // when 0 then free interpreter

static t_hashtab* py_global_registry = NULL; // global object lookups

// static wchar_t* program;

</t>
<t tx="sta.20200602145459.1">#ifndef PY_H
#define PY_H

/* py.h */

@others
@language c
@tabwidth -4
#endif // PY_H
</t>
<t tx="sta.20200602145517.1">/*--------------------------------------------------------------------------*/
// OBJECT TYPES

typedef struct _py {
    /* object header */
    t_object p_ob;

    /* object attributes */
    t_symbol* p_name; /* unique object name */

    /* python-related */
    t_symbol* p_pythonpath; /* path to python directory */
    t_bool p_debug;         /* bool to switch per-object debug state */
    PyObject* p_globals;    /* per object 'globals' python namespace */

    /* infra objects */
    t_patcher* p_patcher; /* to send msgs to objects */
    t_box* p_box;         /* the ui box of the py instance? */

    /* text editor attrs */
    t_object* p_code_editor;
    char** p_code;
    long p_code_size;

    t_fourcc p_code_filetype; // = FOUR_CHAR_CODE('TEXT')
    t_fourcc p_code_outtype;  // = FOUR_CHAR_CODE('TEXT')
    char p_code_filename[MAX_PATH_CHARS];
    char p_code_pathname[MAX_PATH_CHARS];
    short p_code_path;

    t_symbol* p_code_filepath; /* default python filepath to load into
                                  the code editor and object 'globals'
                                  namespace */
    t_bool p_autoload;         /* bool to autoload of p_code_filepath  */

    /* outlet creation */
    void* p_outlet_right;  // right outlet to bang success
    void* p_outlet_middle; // middle outleet to bang error
    void* p_outlet_left;   // left outleet for msg output

} t_py;

</t>
<t tx="sta.20200602145807.1">/*--------------------------------------------------------------------------*/
// GLOBALS

t_class* py_class;                    // global pointer to object class
static int py_global_obj_count;       // when 0 then free interpreter
static t_hashtab* py_global_registry; // global object lookups
</t>
<t tx="sta.20200602150052.1">/*--------------------------------------------------------------------------*/
// FUNCTION TYPES
</t>
<t tx="sta.20200602150129.1">/*--------------------------------------------------------------------------*/
// ENUMS
</t>
<t tx="sta.20200602150250.1">/*--------------------------------------------------------------------------*/
// MACROS
</t>
<t tx="sta.20200602150324.1">/*--------------------------------------------------------------------------*/
// METHODS

/* object creation and destruction */
void* py_new(t_symbol* s, long argc, t_atom* argv);
void py_free(t_py* x);
void py_init(t_py* x);

/* helpers */
void py_log(t_py* x, char* fmt, ...);
void py_error(t_py* x, char* fmt, ...);
void py_init_builtins(t_py* x);
t_hashtab* get_global_registry(void);
void py_locate_path_from_symbol(t_py* x, t_symbol* s);

/* common handlers */
void py_handle_error(t_py* x, char* fmt, ...);
void py_handle_float_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_long_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_string_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_list_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_output(t_py* x, PyObject* pval);

/* core python methods */
void py_import(t_py* x, t_symbol* s);
void py_eval(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_exec(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_execfile(t_py* x, t_symbol* s);

/* extra python methods */
void py_assign(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_code(t_py* x, t_symbol* s, long argc, t_atom* argv);

/* informational */
void py_count(t_py* x);
void py_assist(t_py* x, void* b, long m, long a, char* s);

/* testing */
void py_bang(t_py* x);

/* interobject communications */
void py_scan(t_py* x);
long py_scan_callback(t_py* x, t_object* obj);
void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv);

/* code editor */
void py_read(t_py* x, t_symbol* s);
void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_dblclick(t_py* x);
void py_edclose(t_py* x, char** text, long size);
void py_edsave(t_py* x, char** text, long size);
void py_load(t_py* x, t_symbol* s); // combo of read -&gt; execfile

</t>
<t tx="sta.20200602150733.1">/*--------------------------------------------------------------------------*/
// INCLUDES

/* max api */
#include "ext.h"
#include "ext_obex.h"

/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
</t>
<t tx="sta.20200602150814.1">/*--------------------------------------------------------------------------*/
// CONSTANTS

#define PY_MAX_ATOMS 128
#define PY_MAX_LOG_CHAR 500 // high number during development
#define PY_MAX_ERR_CHAR PY_MAX_LOG_CHAR

</t>
<t tx="sta.20200602151837.1">@path source/py/notes</t>
<t tx="sta.20200602164507.1">@path source/py/tests
</t>
<t tx="sta.20200602164529.1">/* python */

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;



@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602165143.1">/* --------------------------------------- */
// types

typedef struct _py {
    PyObject* p_globals;
} t_py;


#define PY_MAX_LONG 256
#define PY_MAX_FLOAT PY_MAX_LONG

/* --------------------------------------- */
// forward func declarations

int py_import(t_py* x, char* args);
// int py_eval(t_py* x, char* args);
int py_exec(t_py* x, char* args);
int py_execfile(t_py* x, char* args);
int py_run(t_py* x, char* args);

</t>
<t tx="sta.20200602165143.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* module = PyImport_AddModule("__main__"); // borrowed reference
    x-&gt;p_globals = PyModule_GetDict(module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argv[2]);
        // if (strcmp(argv[1], "eval") == 0)
        //     py_eval(x, argv[2]);
        if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argv[2]);
        if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argv[2]);
        if (strcmp(argv[1], "run") == 0)
            py_run(x, argv[2]);
    } else {
        printf("usage: test [import, eval, exec, execfile, run] args\n");
    }

    Py_FinalizeEx();
    return 0;
}


</t>
<t tx="sta.20200602165143.3">void handle_py_error(void)
{
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
}

</t>
<t tx="sta.20200602165143.4">int py_import(t_py* x, char* name)
{
    PyObject* x_module = NULL;

    if (name != NULL) {
        x_module = PyImport_ImportModule(name); // x_module borrrowed ref
        if (x_module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, name, x_module);
        return 0;
    }

error:
    handle_py_error();
    return -1;
}

</t>
<t tx="sta.20200602165143.5">int py_exec(t_py* x, char* statement)
{
    PyObject* pval = NULL;

    if (statement == NULL) {
        goto error;
    }

    pval = PyRun_String(statement, Py_single_input, x-&gt;p_globals,
                        x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}

</t>
<t tx="sta.20200602165143.6">int py_execfile(t_py* x, char* fpath)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (fpath == NULL) {
        goto error;
    }

    fhandle = fopen(fpath, "r");
    if (fhandle == NULL) {
        goto error;
    }

    pval = PyRun_File(fhandle, fpath, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);

    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


</t>
<t tx="sta.20200602165143.7">int py_run(t_py* x, char* fpath)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;
    int ret = 0;

    if (fpath == NULL) {
        goto error;
    }

    pval = Py_BuildValue("s", fpath); // new reference
    if (pval == NULL) {
        goto error;
    }

    fhandle = _Py_fopen_obj(pval, "r+");
    if (fhandle == NULL) {
        goto error;
    }

    ret = PyRun_SimpleFile(fhandle, fpath);
    if (ret == -1) {
        goto error;
    }

    // success
    fclose(fhandle);
    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


PyObject* py_eval_obj(t_py* x, char* expression)
{
    PyObject* pval = PyRun_String(expression, Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);
    if (pval != NULL) {
        return pval;
    } else {
        handle_py_error();
        return NULL;
    }
}


long py_eval_long(t_py* x, char* expression)
{

    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyLong_Check(pval)) {
        goto error;
    }

    long result = PyLong_AsLong(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


double py_eval_double(t_py* x, char* expression)
{

    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyFloat_Check(pval)) {
        goto error;
    }

    double result = PyFloat_AsDouble(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


</t>
<t tx="sta.20200602165143.8">const char* py_eval_unicode(t_py* x, char* expression)
{
    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyUnicode_Check(pval)) {
        goto error;
    }

    const char* result = PyUnicode_AsUTF8(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return NULL;
}

// caller must free
</t>
<t tx="sta.20200602165143.9">float* py_eval_float_seq(t_py* x, char* expression)
{
    // caller must free
    float *result;
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    PyObject* pval = py_eval_obj(x, expression);
    if (pval == NULL) {
        goto error;
    }

    if (!PySequence_Check(pval)) {
        goto error;
    }

    Py_ssize_t length = PySequence_Length(pval);
    if (length == -1) {
        goto error;
    }

    // use calloc instead of malloc to init zeros
    result = (float*)calloc(length, sizeof(float));
    if (result == NULL) {
        goto error;
    }

    if ((iter = PyObject_GetIter(pval)) != NULL) {
        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyFloat_Check(item)) {
                if (PyFloat_AsDouble(item) != -1) {
                    result[i] = (float)PyFloat_AsDouble(item);
                    i++;              
                }    
            }
            Py_DECREF(item);
        }
    }

    // success
    Py_XDECREF(pval);
    return result; // caller must free

    error:
        handle_py_error();
        Py_XDECREF(pval);
        return NULL;
}
// caller must free
</t>
<t tx="sta.20200602165301.1">long* py_eval_long_seq(t_py* x, char* expression)
{
    // caller must free
    long *result;
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    PyObject* pval = py_eval_obj(x, expression);
    if (pval == NULL) {
        goto error;
    }

    if (!PySequence_Check(pval)) {
        goto error;
     }

    Py_ssize_t length = PySequence_Length(pval);
    if (length == -1) {
        goto error;
    }

    // use calloc instead of malloc to init zeros
    result = (long*)calloc(length, sizeof(long));
    if (result == NULL) {
        goto error;
    }

    if ((iter = PyObject_GetIter(pval)) != NULL) {
        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                if (PyLong_AsLong(item) != -1) {
                    result[i] = PyLong_AsLong(item);
                    i++;              
                }    
            }
            Py_DECREF(item);
        }
    }

    // success
    Py_XDECREF(pval);
    return result; // caller must free

    error:
        handle_py_error();
        Py_XDECREF(pval);
        return NULL;
}

// caller must free
</t>
<t tx="sta.20200602165801.1">@language rest
@wrap

This @settings tree contains all active settings.

Settings outside this tree have no effect.

The node "Qt Gui Stylesheet settings" contains most of the setting relating to appearance.
</t>
<t tx="sta.20200602165801.470">@language rest
@wrap

</t>
<t tx="sta.20200602165801.471">If True, names uses headline "Foo.bar" for bar() defined in class
Foo, and headline "bar (foo.py)" for bar() defined at top level in
foo.py.  This is useful if you've cloned the node so its origin is
not obvious from context.

If False, does not do the above, useful if you don't use clones
and don't want the visual clutter of repeated class / file names.</t>
<t tx="sta.20200602165810.1"></t>
<t tx="sta.20200602170210.1">
/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;


@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170222.1">/* --------------------------------------- */
// types

typedef struct _py {
    PyObject* p_globals;
} t_py;

/* --------------------------------------- */
// forward func declarations

void py_import(t_py* x, char* args);
void py_eval(t_py* x, char* args);
void py_exec(t_py* x, char* args);
void py_execfile(t_py* x, char* args);
void py_run(t_py* x, char* args);

</t>
<t tx="sta.20200602170222.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* main_module = PyImport_AddModule(
        "__main__");                              // borrowed reference
    x-&gt;p_globals = PyModule_GetDict(main_module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argv[2]);
        if (strcmp(argv[1], "eval") == 0)
            py_eval(x, argv[2]);
        if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argv[2]);
        if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argv[2]);
        if (strcmp(argv[1], "run") == 0)
            py_run(x, argv[2]);
    } else {
        printf("usage: test [import, eval, exec, execfile, run] args\n");
    }

    Py_FinalizeEx();
    return 0;
}

//--------------------------------------------------------------------------

</t>
<t tx="sta.20200602170222.3">void py_import(t_py* x, char* args)
{
    PyObject* x_module = NULL;

    if (args != NULL) {
        x_module = PyImport_ImportModule(args); // x_module borrrowed ref
        if (x_module == NULL) {
            PyErr_SetString(PyExc_ImportError, "Ooops again.");
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, args, x_module);
        printf("imported: %s\n", args);
    }
    // else goto error;

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('import %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
        // Py_XDECREF(x_module);
    }
}

</t>
<t tx="sta.20200602170222.4">void py_run(t_py* x, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;
    int ret = 0;

    if (args == NULL) {
        printf("%s: could not retrieve args\n", args);
        goto error;
    }

    pval = Py_BuildValue("s", args); // new reference
    if (pval == NULL) {
        goto error;
    }

    fhandle = _Py_fopen_obj(pval, "r+");
    if (fhandle == NULL) {
        printf("could not open file '%s'\n", args);
        goto error;
    }

    ret = PyRun_SimpleFile(fhandle, args);
    if (ret == -1) {
        goto error;
    }

    // success
    fclose(fhandle);
    Py_DECREF(pval);

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('run %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(pval);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
}

</t>
<t tx="sta.20200602170222.5">void py_execfile(t_py* x, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (args == NULL) {
        printf("execfile: could not retrieve arg: %s\n", args);
        goto error;
    }

    fhandle = fopen(args, "r");
    if (fhandle == NULL) {
        printf("could not open file '%s'\n", args);
        goto error;
    }

    pval = PyRun_File(fhandle, args, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('execfile %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(pval);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
}

</t>
<t tx="sta.20200602170222.6">void py_exec(t_py* x, char* args)
{
    PyObject* pval = NULL;

    if (args == NULL) {
        printf("exec: could not retrieve args: %s\n", args);
        goto error;
    }

    pval = PyRun_String(args, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('exec %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(pval);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
}

</t>
<t tx="sta.20200602170222.7">void py_eval(t_py* x, char* args)
{
    PyObject* pval = NULL;
    PyObject* locals = NULL;

    if (args == NULL) {
        printf("eval: could not retrieve quoted args: %s\n", args);
        goto error;
    }

    locals = PyDict_New();
    if (locals == NULL) {
        goto error;
    }

    pval = PyRun_String(args, Py_eval_input, x-&gt;p_globals, locals);
    if (pval == NULL) {
        goto error;
    }

    // handle ints and longs
    if (PyLong_Check(pval)) {
        long int_result = PyLong_AsLong(pval);
        printf("int: %ld\n", int_result);
    }

    // handle floats and doubles
    if (PyFloat_Check(pval)) {
        float float_result = (float)PyFloat_AsDouble(pval);
        printf("int: %f\n", float_result);
    }

    // handle strings
    if (PyUnicode_Check(pval)) {
        const char* unicode_result = PyUnicode_AsUTF8(pval);
        printf("unicode: %s\n", unicode_result);
    }

    // handle lists, tuples and sets
    if (PyList_Check(pval) || PyTuple_Check(pval) || PyAnySet_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);
        if (seq_size &lt;= 0) {
            printf("cannot convert python sequence with zero or less length");
            goto error;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                printf("%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                printf("%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                printf("%d unicode: %s\n", i, unicode_item);
                i++;
            }
            Py_DECREF(item);
        }
        printf("end iter op: %d\n", i);
    }

    // success cleanup
    Py_XDECREF(pval);
    // Py_XDECREF(locals);
    return;

error:
    if (PyErr_Occurred()) {
        // PyErr_Print();
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);

        // get error message
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('eval %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
    // else if (PyErr_ExceptionMatches (PyExc_SyntaxError)) {
    //     // PyErr_Print ();
    //     PyObject *ptype, *pvalue, *ptraceback;
    //     PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);

    //     // get error message
    //     const char *pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
    //     printf("PyException('eval %s'): %s\n", args, pStrErrorMessage);
    //     Py_DECREF(ptype);
    //     Py_DECREF(pvalue);
    //     Py_DECREF(ptraceback);
    // }
    // cleanup
    Py_XDECREF(pval);
    // Py_XDECREF(locals);
}
</t>
<t tx="sta.20200602170255.1">
/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

/* --------------------------------------- */
// types

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170336.1">typedef struct _py {
    PyObject* p_globals;
} t_py;

/* --------------------------------------- */
// forward func declarations

void py_import(t_py* x, int argc, char* argv);
void py_eval(t_py* x, int argc, char* argv);
void py_exec(t_py* x, int argc, char* argv);
void py_execfile(t_py* x, int argc, char* argv);
void py_assign(t_py* x, int argc, char* argv);
void py_anything(t_py* x, int argc, char* argv);
void handle_py_error(void);

</t>
<t tx="sta.20200602170336.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* main_module = PyImport_AddModule("__main__"); // borrowed
    x-&gt;p_globals = PyModule_GetDict(main_module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argc, argv);
        else if (strcmp(argv[1], "eval") == 0)
            py_eval(x, argc, argv);
        else if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argc, argv);
        else if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argc, argv);
        else if (strcmp(argv[1], "assign") == 0)
            py_assign(x, argc, argv);
        else py_anything(x, argc, argv);

    } else {
        printf("usage: test [import, eval, exec, execfile, assign, ...] args\n");
    }

    Py_FinalizeEx();
    return 0;
}


/* python error handler helper function */
</t>
<t tx="sta.20200602170336.3">void handle_py_error(void)
{
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
}


/*--------------------------------------------------------------------------*/
// core python methods

</t>
<t tx="sta.20200602170336.4">void py_import(t_py* x, int argc, char* argv[])
{
    PyObject* module = NULL;

    if (argv != NULL) {
        module = PyImport_ImportModule(argv[2]); // module borrrowed ref
        if (module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, argv[2], module);
        printf("imported: %s\n", argv[2]);
    }
    return;
error:
    handle_py_error();
}


// see: https://codereview.stackexchange.com/questions/71970/creating-a-string-from-command-line-arguments
// see also: (how last entry should be null terminated e.g. filename[63] = '\0';)
// https://stackoverflow.com/questions/19194254/how-can-i-copy-the-contents-of-argv-into-a-c-style-string


</t>
<t tx="sta.20200602170336.5">void py_eval(t_py* x, int argc, char* argv[])
{
    char* py_argv = atom_getsym(argv)-&gt;s_name;
    py_log(x, "%s %s", s-&gt;s_name, py_argv);

    PyObject* pval = PyRun_String(argv[2], Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);

    if (pval != NULL) {

        // handle ints and longs
        if (PyLong_Check(pval)) {
            long int_result = PyLong_AsLong(pval);
        }

        // handle floats and doubles
        if (PyFloat_Check(pval)) {
            float float_result = (float)PyFloat_AsDouble(pval);
        }

        // handle strings
        if (PyUnicode_Check(pval)) {
            const char* unicode_result = PyUnicode_AsUTF8(pval);

        }

        // handle any sequence except strings, and presently
        // bytes and byte arrays (until there is a reason to)
        if (PySequence_Check(pval) &amp;&amp; !PyUnicode_Check(pval)
            &amp;&amp; !PyBytes_Check(pval) &amp;&amp; !PyByteArray_Check(pval)) {
            PyObject* iter;
            PyObject* item;
            int i = 0;

            Py_ssize_t seq_size = PySequence_Length(pval);

            if ((iter = PyObject_GetIter(pval)) != NULL) {
                while ((item = PyIter_Next(iter)) != NULL) {
                    if (PyLong_Check(item)) {
                        long long_item = PyLong_AsLong(item);
                        py_log(x, "%d long: %ld\n", i, long_item);
                        i++;
                    }

                    if PyFloat_Check (item) {
                        float float_item = PyFloat_AsDouble(item);
                        py_log(x, "%d float: %f\n", i, float_item);
                        i++;
                    }

                    if PyUnicode_Check (item) {
                        const char* unicode_item = PyUnicode_AsUTF8(item);
                        py_log(x, "%d unicode: %s\n", i, unicode_item);
                        i++;
                    }
                    Py_DECREF(item);
                }
                py_log(x, "end iter op: %d", i);
            }

        }

        // cleanup
        Py_XDECREF(pval);
    }

    else {
        handle_py_error();
        // cleanup
        Py_XDECREF(pval);
    }
}

</t>
<t tx="sta.20200602170336.6">void py_exec(t_py* x, int argc, char* args)
{
    char* py_argv = NULL;
    PyObject* pval = NULL;

    py_argv = atom_getsym(argv)-&gt;s_name;
    if (py_argv == NULL) {
        goto error;
    }

    pval = PyRun_String(py_argv, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    outlet_bang(x-&gt;p_outlet0);

    // success cleanup
    Py_DECREF(pval);
    py_log(x, "exec %s", py_argv);
    return;

error:
    handle_py_error(x, "exec %s", py_argv);
    Py_XDECREF(pval);
}

</t>
<t tx="sta.20200602170336.7">void py_execfile(t_py* x, int argc, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (s == gensym("")) {
        py_error(x, "py execfile: missing filepath");
        goto error;
    }

    fhandle = fopen(s-&gt;s_name, "r");
    if (fhandle == NULL) {
        py_error(x, "could not open file '%s'", s-&gt;s_name);
        goto error;
    }

    pval = PyRun_File(fhandle, s-&gt;s_name, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    outlet_bang(x-&gt;p_outlet0);

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    py_log(x, "execfile %s", s-&gt;s_name);
    return;

error:
    handle_py_error(x, "execfile %s", s-&gt;s_name);
    Py_XDECREF(pval);
}

/*--------------------------------------------------------------------------*/
// extra python methods

</t>
<t tx="sta.20200602170336.8">void py_assign(t_py* x, int argc, char* args)
{
    char* varname = NULL;
    PyObject* list = NULL;

    if (s != gensym(""))
        py_log(x, "s: %s", s-&gt;s_name);

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        // strncpy_zero(varname, atom_getsym(argv)-&gt;s_name, 50);
        varname = atom_getsym(argv)-&gt;s_name;
        py_log(x, "varname: %s", varname);
    }

    if ((list = PyList_New(0)) == NULL) {
        py_error(x, "list == NULL");
        goto error;
    }

    // NOTE: n C it’s illegal to have a declaration as the first statement
    // after a label enclosing the whole subblock in a {} seems to work
    for (int i = 1; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                error("p_float == NULL");
                goto error;
            }
            PyList_Append(list, p_float);
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;
            }
            PyList_Append(list, p_long);
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;
            }
            PyList_Append(list, p_str);
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    if (PyList_Size(list) != argc - 1) {
        py_error(x, "PyList_Size(list) != argc - 1");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(list));
    }

    // finally, assign list to varname in object namespace
    py_log(x, "setting %s to list in namespace", varname);
    int res = PyDict_SetItemString(x-&gt;p_globals, varname, list);
    if (res != 0) {
        py_error(x, "assign varname to list failed");
        goto error;
    }
    // Py_XDECREF(list); // causes a crash
    return;

error:
    handle_py_error(x, "assign %s", s-&gt;s_name);
    Py_XDECREF(list);
}

</t>
<t tx="sta.20200602170336.9">void py_anything(t_py* x, int argc, char* args)
{
    char* py_argv = NULL;
    PyObject* pval = NULL;
    // PyObject* py_callable_str = NULL;
    PyObject* py_callable = NULL;
    PyObject* py_argslist = NULL; // python list
    PyObject* py_args = NULL;     // python tuple

    if (s == gensym("")) {
        py_error(x, "could not retrieve callable name", s-&gt;s_name);
        goto error;
    }

    py_callable = PyRun_String(s-&gt;s_name, Py_eval_input, x-&gt;p_globals,
                               x-&gt;p_globals);
    if (py_callable == NULL) {
        py_error(x, "could not evaluate '%s' as a python callable", s-&gt;s_name);
        goto error;
    }

    if ((py_argslist = PyList_New(0)) == NULL) {
        py_error(x, "could not create an empyt python list");
        goto error;
    }

    for (int i = 0; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                py_error(x, "p_float == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_float);
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_long);
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_str);
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    if (PyList_Size(py_argslist) != argc) {
        py_error(x, "PyList_Size(list) != argc");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(py_argslist));
    }

    // convert py_args to tuple
    py_args = PyList_AsTuple(py_argslist);
    if (py_args == NULL) {
        py_error(x, "unable to convert args list to tuple");
        goto error;
    }

    pval = PyObject_Call(py_callable, py_args, NULL);
    if (pval == NULL) {
        py_error(x, "could not retrieve result of call");
        goto error;
    }

    // handle ints and longs
    if (PyLong_Check(pval)) {
        long int_result = PyLong_AsLong(pval);
        outlet_int(x-&gt;p_outlet1, int_result);
    }

    // handle floats and doubles
    if (PyFloat_Check(pval)) {
        float float_result = (float)PyFloat_AsDouble(pval);
        outlet_float(x-&gt;p_outlet1, float_result);
    }

    // handle strings
    if (PyUnicode_Check(pval)) {
        const char* unicode_result = PyUnicode_AsUTF8(pval);
        outlet_anything(x-&gt;p_outlet1, gensym(unicode_result), 0, NIL);
    }

    // handle lists, tuples and sets
    if (PyList_Check(pval) || PyTuple_Check(pval) || PyAnySet_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);
        if (seq_size &lt;= 0) {
            py_error(x,
                     "cannot convert python sequence with zero or less length "
                     "to atoms");
            goto error;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }
        outlet_list(x-&gt;p_outlet1, NULL, i, atoms);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }

    // success cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
    py_log(x, "END %s: %s", s-&gt;s_name, py_argv);
    return;

error:
    handle_py_error(x, "anythinh %s", s-&gt;s_name);
    // cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
}
</t>
<t tx="sta.20200602170358.1">#include &lt;stdio.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170405.1">/*

Analysis finished in 314mss

No issues found

*/


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define BUFFER_SIZE 20

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170419.1">/*

Analysis finished in 268mss

Found 3 issues

test_args.c:55: error: MEMORY_LEAK
  memory dynamically allocated by call to `malloc()` at line 52, column 25 is not reachable after line 55, column 9.
  53.
  54.       for(i = 1; i &lt;= size; i++) {
  55. &gt;         str = (char *)realloc(str, (v + strlen(argv[i])));
  56.           strcat(str, argv[i]);
  57.           strcat(str, " ");

test_args.c:60: error: MEMORY_LEAK
  memory dynamically allocated by call to `malloc()` at line 52, column 25 is not reachable after line 60, column 5.
  58.       }
  59.
  60. &gt;     printf("%s\n", str);
  61.       return 0;
  62.   }

test_args.c:56: error: NULL_DEREFERENCE
  pointer `str` last assigned on line 55 could be null and is dereferenced by call to `strcat()` at line 56, column 9.
  54.       for(i = 1; i &lt;= size; i++) {
  55.           str = (char *)realloc(str, (v + strlen(argv[i])));
  56. &gt;         strcat(str, argv[i]);
  57.           strcat(str, " ");
  58.       }


Summary of the reports

       MEMORY_LEAK: 2
  NULL_DEREFERENCE: 1

*/


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170439.1">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


char *foo(int count) {
    char *ret = malloc(count);
    if(!ret)
        return NULL;

    for(int i = 0; i &lt; count; ++i) 
        ret[i] = i;

    return ret;
}



void doit(char *buf, int count) {
    for(int i = 0; i &lt; count; ++i)
        buf[i] = i;
}


@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170448.1">#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170456.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170502.1">@others
@language python
@tabwidth -4
</t>
<t tx="sta.20200602170513.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170550.1">int main(int argc, char* argv[])
{
    PyObject *pName, *pModule, *pFunc;
    PyObject *pArgs, *pValue;
    int i;

    if (argc &lt; 3) {
        fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
        return 1;
    }

    Py_Initialize();
    pName = PyUnicode_DecodeFSDefault(argv[1]);
    /* Error checking of pName left out */

    pModule = PyImport_Import(pName);
    Py_DECREF(pName);

    if (pModule != NULL) {
        pFunc = PyObject_GetAttrString(pModule, argv[2]);
        /* pFunc is a new reference */

        if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {
            pArgs = PyTuple_New(argc - 3);
            for (i = 0; i &lt; argc - 3; ++i) {
                pValue = PyLong_FromLong(atoi(argv[i + 3]));
                if (!pValue) {
                    Py_DECREF(pArgs);
                    Py_DECREF(pModule);
                    fprintf(stderr, "Cannot convert argument\n");
                    return 1;
                }
                /* pValue reference stolen here: */
                PyTuple_SetItem(pArgs, i, pValue);
            }
            pValue = PyObject_CallObject(pFunc, pArgs);
            Py_DECREF(pArgs);
            if (pValue != NULL) {
                printf("Result of call: %ld\n", PyLong_AsLong(pValue));
                Py_DECREF(pValue);
            } else {
                Py_DECREF(pFunc);
                Py_DECREF(pModule);
                PyErr_Print();
                fprintf(stderr, "Call failed\n");
                return 1;
            }
        } else {
            if (PyErr_Occurred())
                PyErr_Print();
            fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
        }
        Py_XDECREF(pFunc);
        Py_DECREF(pModule);
    } else {
        PyErr_Print();
        fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
        return 1;
    }
    if (Py_FinalizeEx() &lt; 0) {
        return 120;
    }
    return 0;
}
</t>
<t tx="sta.20200602170553.1">import os

import pytest
from conftest import cwd, join

MODULES = ["os", "sys", "math"]

EXPRESSIONS = {
    "1+1": "int: 2",
    "2*10": "int: 20"
}

EVAL_FAIL = [
    # syntax errors
    "000000000000007",
    "000777", 
    "0777",
    "077787", 
    "090000000000000",
    "0b100e1", 
    "0b101j2", 
    "0e",
    "0o153j2", 
    "0o777e1", 
    "0x.", 
    "0xj", 
    "lambda a,a:0",
    "lambda a,a=1:0",
    "lambda a=1,a=1:0",
]

EVAL_EQUALS = [
    ("0xff", 255)
    ("0777.", 777)
    ("0777.0", 777)
    ("000000000000000000000000000000000000000000000000000777e0", 777)
    ("0777e1", 7770)
    ("0e0", 0)
    ("0000e-012", 0)
    ("09.5", 9.5)
    ("000", 0)
    ("00.0", 0)
    ("0e3", 0)
    ("090000000000000.", 90000000000000.)
    ("090000000000000.0000000000000000000000", 90000000000000.)
    ("090000000000000e0", 90000000000000.)
    ("090000000000000e-0", 90000000000000.)
    ("000000000000008.", 8.)
    ("000000000000009.", 9.)
    ("0b101010", 42)
    ("-0b000000000010", -2)
    ("0o777", 511)
    ("-0o0000010", -8)
]

EXEC_FAIL = [
    # syntax errors
    'def f(a, a): pass',
    'def f(a = 0, a = 1): pass',
    'def f(a): global a; a = 1',
    'def f(a=1, b): pass',
    'None = 0',
    'None += 0',
    '__builtins__.None = 0',
    'def None(): pass',
    'class None: pass',
    '(a, None) = 0, 0',
    'for None in range(10): pass',
    'def f(None): pass',
    'import None',
    'import x as None',
    'from x import None',
    'from x import y as None',
]

IMPORT_FAIL = [
    'import (os, sys)',
    'import (os), (sys)',
    'import ((os), (sys))',
    'import (sys',
    'import sys)',
    'import (os,)',
    'import os As bar',
    'import os.path a bar',
    'from sys import stdin As stdout',
    'from sys import stdin a stdout',
    'from (sys) import stdin',
    'from __future__ import (nested_scopes',
    'from __future__ import nested_scopes)',
    'from __future__ import nested_scopes,\ngenerators',
    'from sys import (stdin',
    'from sys import stdin)',
    'from sys import stdin, stdout,\nstderr',
    'from sys import stdin si',
    'from sys import stdin,',
    'from sys import (*)',
    'from sys import (stdin,, stdout, stderr)',
    'from sys import (stdin, stdout),',
    ]




IMPORT_SUCCEED = [
    'import sys',
    'import os, sys',
    'import os as bar',
    'import os.path as bar',
    'from __future__ import nested_scopes, generators',
    'from __future__ import (nested_scopes,\ngenerators)',
    'from __future__ import (nested_scopes,\ngenerators,)',
    'from sys import stdin, stderr, stdout',
    'from sys import (stdin, stderr,\nstdout)',
    'from sys import (stdin, stderr,\nstdout,)',
    'from sys import (stdin\n, stderr, stdout)',
    'from sys import (stdin\n, stderr, stdout,)',
    'from sys import stdin as si, stdout as so, stderr as se',
    'from sys import (stdin as si, stdout as so, stderr as se)',
    'from sys import (stdin as si, stdout as so, stderr as se,)',
    ]





</t>
<t tx="sta.20200602170553.2">@pytest.fixture(scope="module", params=MODULES)
def module(request):
    expr = request.param
    yield expr

</t>
<t tx="sta.20200602170553.3">@pytest.fixture(scope="module", params=EXPRESSIONS.keys())
def expression(request):
    mod = request.param
    yield mod



</t>
<t tx="sta.20200602170553.4">def test_import(capfd, module):
    arg = f'import {module}'
    os.system(f'./tests/test_py {arg}')
    captured = capfd.readouterr()
    assert captured.out == f"imported: {module}\n"


</t>
<t tx="sta.20200602170553.5">def test_import_error(capfd):
    arg = f'import hello'
    os.system(f'./tests/test_py {arg}')
    captured = capfd.readouterr()
    assert captured.out == f"PyException('{arg}'): Ooops again.\n"

</t>
<t tx="sta.20200602170553.6">def test_eval(capfd, expression):
    arg = f'eval {expression}'
    os.system(f'./tests/test_py {arg}')
    captured = capfd.readouterr()
    result = EXPRESSIONS[expression]
    assert captured.out == f"{result}\n"

</t>
<t tx="sta.20200602170556.1">int main(int argc, char *argv[]) {
    (void)argc;
    wchar_t *program = Py_DecodeLocale(argv[0], NULL);
    if (program == NULL) {
        fprintf(stderr, "Fatal error: cannot decode argv[0]\n");
        exit(1);
    }
    Py_SetProgramName(program);
    Py_Initialize();
    PyRun_SimpleString(argv[1]);
    if (Py_FinalizeEx() &lt; 0) {
        exit(120);
    }
    PyMem_RawFree(program);
    return 0;
}
</t>
<t tx="sta.20200602170558.1">void printf2(char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

</t>
<t tx="sta.20200602170558.2">void sprintf2(char* buf, char* fmt, ...)
{
    va_list va;
    va_start(va, fmt);
    vsprintf(buf, fmt, va);
    va_end(va);
}

</t>
<t tx="sta.20200602170558.3">void test_sprintf2(void)
{
    char buff[100];
    sprintf2(buff, "Hello, %s, aged %d", "Jo", 27);
    printf("%s\n", buff);
}

</t>
<t tx="sta.20200602170558.4">int main()
{
    printf("printf: hello %d\n", 1);
    printf2("printf2: hello %d\n", 1);
    test_sprintf2();
}
</t>
<t tx="sta.20200602170602.1">int main()
{
	char txt[10] = {0};
    char txt1[50] = "Hello World";
    char* txt2 = "World Hello";
    char** p_txt = &amp;txt2;
    doit(txt, 10);

    char *p = foo(10);
    if(p) {
        printf("p: %s length: %ld\n", p, strlen(p));
        free(p);
    }

    printf("txt1: %s length: %ld\n", txt1, strlen(txt1));
    printf("txt2: %s length: %ld\n", txt2, strlen(txt2));
    printf("p_txt: %s length: %ld\n", *p_txt, strlen(*p_txt));
    printf("txt: %s length: %ld\n", txt, strlen(txt));
}
</t>
<t tx="sta.20200602170604.1">int main(int argc, char *argv[]) {
    if(argc == 1) {
        printf("ERROR: Expected at least 1 argument\n");
        return 0;
    }

    int i, v = 0, size = argc - 1;

    char *str = (char *)malloc(v);

    for(i = 1; i &lt;= size; i++) {
        str = (char *)realloc(str, (v + strlen(argv[i])));
        strcat(str, argv[i]);
        strcat(str, " ");
    }

    printf("%s\n", str);
    return 0;
}
</t>
<t tx="sta.20200602170608.1">int main(int argc, char *argv[]) {

    char buffer[BUFFER_SIZE];
    int total_input_length = 0;

    if(argc == 1) {
        printf("ERROR: Expected at least 1 argument\n");
        return 0;
    }

    for (int i=1; i &lt;= argc-1; i++) {
        total_input_length += strlen(argv[i]);
    }

    if (total_input_length &gt; BUFFER_SIZE-1) {
        printf("input length of %d &gt; available buffer length of %d by %d characters.\n",
        total_input_length, BUFFER_SIZE-1, total_input_length - (BUFFER_SIZE-1));
        exit(1);
    }

    // copy first
    strncpy(buffer, argv[1], BUFFER_SIZE-1);
    buffer[BUFFER_SIZE-1] = '\0';

    for(int i = 2; i &lt;= argc-1; i++) {
        printf("%d.1 strlen(buffer): %ld\n", i, strlen(buffer));
        strncat(buffer, " ", BUFFER_SIZE - strlen(buffer) - 1);
        printf("%d.2 strlen(buffer): %ld\n", i, strlen(buffer));
        strncat(buffer, argv[i], BUFFER_SIZE - strlen(buffer) - 1);
    }

    printf("final strlen(buffer): %ld\n", strlen(buffer));
    printf("%s\n", buffer);
    return 0;
}
</t>
<t tx="sta.20200602170611.1">int main()
{
    int x = 10;
    // fall through with no return!

hello:
    x++;
    printf("hello: %d\n", x);

bye:
    x++;
    printf("bye: %d\n", x);

    return 0;
}
</t>
<t tx="sta.20200602174033.1">#include &lt;stdio.h&gt;

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;compile.h&gt;
#include &lt;eval.h&gt;
#include &lt;object.h&gt;

#include "readline.h"

int add_history(char*);

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602174134.1">int main(int argc, char* argv[])
{
    int i, j, done = 0; /* lengths of line, code */
    char ps1[] = "&gt;&gt;&gt; ";
    char ps2[] = "... ";
    char* prompt = ps1;
    char *msg, *line, *code = NULL;
    PyObject *src, *glb, *loc;
    PyObject *exc, *val, *trb, *obj, *dum;

    Py_Initialize();
    loc = PyDict_New();
    glb = PyDict_New();
    PyDict_SetItemString(glb, "__builtins__", PyEval_GetBuiltins());

    while (!done) {
        line = readline(prompt);

        if (NULL == line) /* Ctrl-D pressed */
        {
            done = 1;
        } else {
            i = strlen(line);

            if (i &gt; 0)
                add_history(line); /* save non-empty lines */

            if (NULL == code) /* nothing in code yet */
                j = 0;
            else
                j = strlen(code);

            code = realloc(code, i + j + 2);
            if (NULL == code) /* out of memory */
                exit(1);

            if (0 == j)         /* code was empty, so */
                code[0] = '\0'; /* keep strncat happy */

            strncat(code, line, i); /* append line to code */
            code[i + j] = '\n';     /* append '\n' to code */
            code[i + j + 1] = '\0';

            src = Py_CompileString(code, "&lt;stdin&gt;", Py_single_input);

            if (NULL != src) /* compiled just fine - */
            {
                if (ps1 == prompt ||         /* "&gt;&gt;&gt; " or */
                    '\n' == code[i + j - 1]) /* "... " and double '\n' */
                {                            /* so execute it */
                    dum = PyEval_EvalCode(src, glb, loc);
                    Py_XDECREF(dum);
                    Py_XDECREF(src);
                    free(code);
                    code = NULL;
                    if (PyErr_Occurred())
                        PyErr_Print();
                    prompt = ps1;
                }
            } /* syntax error or E_EOF? */
            else if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
                PyErr_Fetch(&amp;exc, &amp;val, &amp;trb); /* clears exception! */

                if (PyArg_ParseTuple(val, "sO", &amp;msg, &amp;obj)
                    &amp;&amp; !strcmp(msg,
                               "unexpected EOF while parsing")) /* E_EOF */
                {
                    Py_XDECREF(exc);
                    Py_XDECREF(val);
                    Py_XDECREF(trb);
                    prompt = ps2;
                } else /* some other syntax error */
                {
                    PyErr_Restore(exc, val, trb);
                    PyErr_Print();
                    free(code);
                    code = NULL;
                    prompt = ps1;
                }
            } else /* some non-syntax error */
            {
                PyErr_Print();
                free(code);
                code = NULL;
                prompt = ps1;
            }

            free(line);
        }
    }

    Py_XDECREF(glb);
    Py_XDECREF(loc);
    Py_Finalize();
    exit(0);
}
</t>
<t tx="sta.20200603072826.1">long py_scan_callback(t_py* x, t_object* box)
{
    t_rect jr;
    t_object* p;
    t_symbol* s;
    t_symbol* varname;
    t_object* obj;
    t_symbol* obj_id;

    jbox_get_patching_rect(box, &amp;jr);
    p = jbox_get_patcher(box);
    varname = jbox_get_varname(box);
    obj = jbox_get_object(box);

    // STRANGE BUG: single quotes in py_log cause a crash but not with post!!
    // perhaps because post is a macro for object_post?
    if (varname &amp;&amp; varname != gensym("")) {
        // post("XXXX -&gt; '%s'", varname-&gt;s_name);
        py_log(x, "storing object %s in the global registry", varname-&gt;s_name);
        hashtab_store(py_global_registry, varname, obj);
    }

    obj_id = jbox_get_id(box);
    s = jpatcher_get_name(p);
    object_post(
        (t_object*)x,
        "in patcher:%s, varname:%s id:%s box @ x %ld y %ld, w %ld, h %ld",
        s-&gt;s_name, varname-&gt;s_name, obj_id-&gt;s_name, (long)jr.x, (long)jr.y,
        (long)jr.width, (long)jr.height);
    return 0;
}

</t>
<t tx="sta.20200605120205.1">void py_locatefile(t_py* x, char* filename)
{
    // works for folders as well
    char name[MAX_FILENAME_CHARS];
    short path;
    t_fourcc type;

    char pathname[MAX_PATH_CHARS];
    short err;

    if (filename == NULL)
        return;

    strncpy_zero(name, filename, MAX_FILENAME_CHARS);

    if (locatefile_extended(name, &amp;path, &amp;type, NULL, 0)) {
        error("path %s not found", name);
    } else {
        post("path %s, path %d", name, path);
        err = path_topathname(path, name, pathname);
        if (err == 0) {
            post("absolute path: %s", pathname);
        }
    }
}

</t>
<t tx="sta.20200605120324.1">void py_code(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* co = NULL;
    PyObject* pval = NULL;
    t_max_err err;
    int is_eval = 1;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "call %s", text);
    } else {
        goto error;
    }

    co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_eval_input);

    if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
        PyErr_Clear();
        co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_single_input);
        is_eval = 0;
    }

    if (co == NULL) { // can be eval-co or exec-co or NULL here
        goto error;
    }
    sysmem_freeptr(text);

    pval = PyEval_EvalCode(co, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    Py_DECREF(co);

    if (!is_eval) {
        // bang for exec-type op
        outlet_bang(x-&gt;p_outlet_right);
    } else {
        py_handle_output(x, pval);
    }
    return;

error:
    py_handle_error(x, "call failed");
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200606044751.1">void py_handle_output(t_py* x, PyObject* pval)
{
    // &lt;python type&gt; -&gt; left outlet output handlers
    // error handling is already provided in each handler
    py_handle_float_output(x, pval, 0);
    py_handle_long_output(x, pval, 0);
    py_handle_string_output(x, pval, 0);
    py_handle_list_output(x, pval, 0);

    // final cleanup
    Py_XDECREF(pval);
    return;
}

</t>
<t tx="sta.20200606073716.1"></t>
<t tx="sta.20200607084251.1">void py_eval2(t_py* x, t_symbol* s, long argc, t_atom* argv)
{

    long textsize = 0;
    char* text = NULL;
    PyObject* pval = NULL;
    t_max_err err;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    // OBEX_UTIL_ATOM_GETTEXT_SYM_NO_QUOTE);

    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "eval %s", text);
    } else {
        goto error;
    }

    pval = PyRun_String(text, Py_eval_input, x-&gt;p_globals, x-&gt;p_globals);

    if (pval == NULL) {
        sysmem_freeptr(text);
        goto error;
    }

    // success
    sysmem_freeptr(text);
    py_handle_output(x, pval);
    return;

error:
    py_handle_error(x, "eval failure");
}

</t>
<t tx="sta.20200607084300.1">void py_exec2(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* pval = NULL;
    t_max_err err;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "exec %s", text);
    } else {
        goto error;
    }

    pval = PyRun_String(text, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        sysmem_freeptr(text);
        goto error;
    }

    // success cleanup
    sysmem_freeptr(text);
    Py_DECREF(pval);
    // success bang
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "exec failed");
    Py_XDECREF(pval);
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200608031546.1">
@language python</t>
<t tx="sta.20200608031559.1">from os import listdir
from fnmatch import fnmatch
from os.path import join, abspath, basename, normpath, isfile, isdir, splitext

DEFAULT_IGNORE = ['*.pyc', '*.leo', '*.gif', '*.png', '*.jpg', '*.json']
DEFAULT_PARSE = { 'py':'clean', 'txt':'auto', 'css':'auto', 'html':'auto'}


class LeoDirectory(object):
    def __init__(self, path, to_parse=DEFAULT_PARSE, to_ignore=DEFAULT_IGNORE,
            relative_paths=True, sort=True):
        self.path = path
        self.to_parse = to_parse
        self.to_ignore = to_ignore
        self.relative_paths = relative_paths
        self.sort = sort
        assert isdir(path), "%s is not a directory" % path

    def match_to_ignore(self, string):
        return any(fnmatch(string, p) for p in self.to_ignore)

    def is_ignorable(self, string):
        return any([string.startswith('.'), self.match_to_ignore(string)])

    def parse(self, path):
        name, ext = splitext(path)
        ext = ext[1:]
        return name, ext

    def is_parsable(self, path):
        if isfile(path):
            name, ext = self.parse(path)
            if ext in self.to_parse:
                return True
        if isdir(path):
            # is directory can pass
            g.es('---&gt; '+ path)
            return True

        return False

    def headline_from_path(self, path):
        filename = basename(path)
        name, ext = self.parse(path)
        nodetype = self.to_parse[ext] if (ext in self.to_parse) else 'asis'
        return "@%s %s" % (nodetype, filename)

    def body_from_path(self, path):
        body = "@path %s" % normpath(path)
        return body

    def leo_from_directory(self, directory, parent=None, isroot=True, sort=True):
        if not self.relative_paths: directory = abspath(directory)
        if isroot:
            body = self.body_from_path(directory)
            c.setBodyString(p, body)

        dirlist = sorted(listdir(directory)) if sort else listdir(directory)
        for name in dirlist:
            if self.is_ignorable(name):
                g.es("ignore: "+name)
                continue
            path = join(directory, name)
            if isfile(path):
                g.es('file:', path)
                headline = self.headline_from_path(path)
                if parent:
                    node = parent
                else:
                    node = p
                child = node.insertAsLastChild()
                child.initHeadString(headline)
            else:
                g.es('dir:', path)
                headline = basename(path)
                body = self.body_from_path(path)
                if parent:
                    node = parent
                else:
                    node = p
                child = node.insertAsLastChild()
                child.initHeadString(headline)
                child.initBodyString(body)
                self.leo_from_directory(path, parent=child, isroot=False)

    def render(self):
        try:
            self.leo_from_directory(self.path, sort=self.sort)
        finally:
            c.redraw()

LeoDirectory('.').render()</t>
<t tx="sta.20200608031946.1"></t>
<t tx="sta.20200608042323.1">/*--------------------------------------------------------------------------*/
// COMMON HANDLERS

</t>
<t tx="sta.20200608043930.1">void py_lookup(t_py* x, t_symbol* s)
{
    t_object* obj = NULL;
    t_max_err err = NULL;

    if (hashtab_getsize(py_global_registry) == 0) {
        py_error(x, "registry not populated");
        return;
    }

    err = hashtab_lookup(py_global_registry, s, &amp;obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found with name %s", s-&gt;s_name);
    } else {
        py_log(x, "found object: %s", s-&gt;s_name);
    }
    return;
}

</t>
<t tx="sta.20200610070057.1">
void py_send_from_seq(t_py* x, PyObject* seq)
{

    if (seq == NULL) {
        goto error;
    }

    if (!PySequence_Check(seq) || PyUnicode_Check(seq) || PyBytes_Check(seq)
        || PyByteArray_Check(seq)) {
        goto error;
    }

    // list -&gt; t_atom vars
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    t_atom atoms_static[PY_MAX_ATOMS];
    t_atom* atoms = NULL;
    int is_dynamic = 0;

    Py_ssize_t seq_size = PySequence_Length(seq);
    long argc = (long)seq_size;

    if (seq_size &lt; 2) {
        py_error(x, "cannot convert py sequence length &lt; 2 to atoms");
        goto error;
    }

    if (seq_size &gt; PY_MAX_ATOMS) {
        py_log(x, "dynamically increasing size of atom array");
        atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS, seq_size + 1);
        is_dynamic = 1;

    } else {
        atoms = atoms_static;
    }

    if ((iter = PyObject_GetIter(seq)) == NULL) {
        goto error;
    }

    while ((item = PyIter_Next(iter)) != NULL) {
        if (PyLong_Check(item)) {
            long long_item = PyLong_AsLong(item);
            atom_setlong(atoms + i, long_item);
            py_log(x, "%d long: %ld\n", i, long_item);
            i++;
        }

        if PyFloat_Check (item) {
            float float_item = PyFloat_AsDouble(item);
            atom_setfloat(atoms + i, float_item);
            py_log(x, "%d float: %f\n", i, float_item);
            i++;
        }

        if PyUnicode_Check (item) {
            const char* unicode_item = PyUnicode_AsUTF8(item);
            py_log(x, "%d unicode: %s\n", i, unicode_item);
            atom_setsym(atoms + i, gensym(unicode_item));
            i++;
        }
        Py_DECREF(item);
    }

    // send vars
    t_object* obj = NULL;
    char* obj_name = NULL;
    t_symbol* msg_sym = NULL;
    t_max_err err = NULL;

    if ((atoms + 0)-&gt;a_type != A_SYM) {
        py_error(
            x, "1st arg of send needs to be a symbol name of receiver object");
        goto error;
    }

    // argv+0 is the object name to send to
    obj_name = atom_getsym(atoms)-&gt;s_name;
    if (obj_name == NULL) {
        goto error;
    }

    // if registry is empty, scan it
    if (hashtab_getsize(py_global_registry) == 0) {
        py_scan(x);
    }

    // // lookup name in registry
    err = hashtab_lookup(py_global_registry, gensym(obj_name), &amp;obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found in the registry");
        goto error;
    }

    // atom after the name of the receiver
    switch ((atoms + 1)-&gt;a_type) {
    case A_SYM: {
        msg_sym = atom_getsym(atoms + 1);
        if (msg_sym == NULL) { // should check type here
            goto error;
        }
        // address the minimum case: e.g a bang
        if (argc - 2 == 0) { //
            argc = 0;
            atoms = NULL;
        } else {
            argc = argc - 2;
            atoms = atoms + 2;
        }
        break;
    }
    case A_FLOAT: {
        msg_sym = gensym("float");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        atoms = atoms + 1;

        break;
    }
    case A_LONG: {
        msg_sym = gensym("int");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        atoms = atoms + 1;

        break;
    }
    default:
        py_log(x, "cannot process unknown type");
        break;
    }

    // methods to get method type
    t_messlist* messlist = object_mess((t_object*)obj, msg_sym);
    if (messlist) {
        post("messlist-&gt;m_sym  (name of msg): %s", messlist-&gt;m_sym-&gt;s_name);
        post("messlist-&gt;m_type (type of msg): %d", messlist-&gt;m_type[0]);
    }

    err = object_method_typed(obj, msg_sym, argc, atoms, NULL);
    if (err) {
        py_error(x, "failed to send a message to object %s", obj_name);
        goto error;
    }

    // process here
    outlet_bang(x-&gt;p_outlet_right);
    py_log(x, "end iter op: %d", i);

    if (is_dynamic) {
        py_log(x, "restoring to static atom array");
        atom_dynamic_end(atoms_static, atoms);
    }

    // final cleanup
    Py_XDECREF(seq);
    return;

error:
    py_error(x, "send failed");
    return;
}
</t>
<t tx="sta.20200610100158.1">PyObject* py_atom_to_list(t_py* x, long argc, t_atom* argv, int start_from)
{

    PyObject* plist = NULL; // python list

    if ((plist = PyList_New(0)) == NULL) {
        py_error(x, "could not create an empty python list");
        goto error;
    }

    for (int i = start_from; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                goto error;
            }
            PyList_Append(plist, p_float);
            Py_DECREF(p_float);
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                goto error;
            }
            PyList_Append(plist, p_long);
            Py_DECREF(p_long);
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                goto error;
            }
            PyList_Append(plist, p_str);
            Py_DECREF(p_str);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }
    return plist;

error:
    py_error(x, "atom to list conversion failed");
    return NULL;
}

</t>
<t tx="sta.20200610100240.1">/*--------------------------------------------------------------------------*/
// TRANSLATORS
</t>
<t tx="sta.20200610104609.1">void py_handle_long_output(t_py* x, PyObject* plong, bool free_now)
{
    if (plong == NULL) {
        goto error;
    }

    if (PyLong_Check(plong)) {
        long long_result = PyLong_AsLong(plong);
        if (long_result == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        outlet_int(x-&gt;p_outlet_left, long_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    if (free_now) {
        Py_XDECREF(plong);
    }
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(plong);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200610104706.1">
void py_handle_list_output(t_py* x, PyObject* plist, bool free_now)
{
    Py_ssize_t seq_size = PySequence_Length(plist);

    long argc = (long)seq_size;
    t_atom* argv = py_list_to_atom(x, plist);

    outlet_list(x-&gt;p_outlet_left, NULL, argc, argv);
    outlet_bang(x-&gt;p_outlet_right);
    
    free atoms
    for (int i=0; i &lt; argc; i++) {
        sysmem_freeptr((argv+i));
    }
    sysmem_freeptr(argv);

    if (free_now) {
        Py_XDECREF(plist);
    }
    return;
}
</t>
<t tx="sta.20200610105537.1">void py_handle_string_output(t_py* x, PyObject* pstring, bool free_now)
{
    if (pstring == NULL) {
        goto error;
    }

    if (PyUnicode_Check(pstring)) {
        const char* unicode_result = PyUnicode_AsUTF8(pstring);
        if (unicode_result == NULL) {
            goto error;
        }
        outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
        outlet_bang(x-&gt;p_outlet_right);
    }

    if (free_now) {
        Py_XDECREF(pstring);
    }
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pstring);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200610164212.1">
void py_list_to_atom2(t_py* x, PyObject* plist, long* argc, t_atom** argv)
{
    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            py_error(x, "cannot convert py sequence of length 0 to atoms");
            goto error;
        }

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                atom_setlong(*argv + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                atom_setfloat(*argv + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(*argv + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }
        Py_XDECREF(plist);
        return;
    }

error:
    py_handle_error(x, "atom to list conversion failed");
    Py_XDECREF(plist);
}
</t>
<t tx="sta.20200610181828.1">void py_handle_float_output(t_py* x, PyObject* pfloat, bool free_now)
{
    if (pfloat == NULL) {
        goto error;
    }

    if (PyFloat_Check(pfloat)) {
        float float_result = (float)PyFloat_AsDouble(pfloat);
        if (float_result == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }

        outlet_float(x-&gt;p_outlet_left, float_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    if (free_now) {
        Py_XDECREF(pfloat);
    }
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pfloat);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200610222640.1">t_atom* py_list_to_atom(t_py* x, PyObject* plist)
{
    if (plist == NULL) {
        goto error;
    }

    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;
        
        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            py_error(x, "cannot convert py list of length 0 to atoms");
            goto error;
        }
        
        long argc = (long)seq_size;
        t_atom* atoms = (t_atom *)sysmem_newptr(sizeof(t_atom *) * argc);
        // free with sysmem_freeptr(atoms)

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check(item) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check(item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }
        Py_XDECREF(plist);
        return atoms;
    }

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(plist);
    return NULL;
}

</t>
<t tx="sta.20200610231913.1">void py_handle_list_output(t_py* x, PyObject* plist, bool free_now)
{
    if (plist == NULL) {
        goto error;
    }

    if (PySequence_Check(plist) &amp;&amp; !PyUnicode_Check(plist)
        &amp;&amp; !PyBytes_Check(plist) &amp;&amp; !PyByteArray_Check(plist)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(plist);

        if (seq_size == 0) {
            py_error(x, "cannot convert py list of length 0 to atoms");
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        if ((iter = PyObject_GetIter(plist)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                atom_setsym(atoms + i, gensym(unicode_item));
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                i++;
            }
            Py_DECREF(item);
        }

        outlet_list(x-&gt;p_outlet_left, NULL, i, atoms);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }

    if (free_now) {
        Py_XDECREF(plist);
    }
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(plist);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200611235620.1">t_hashtab* get_global_registry(void) { return py_global_registry; }


</t>
<t tx="sta.20200612043307.1"></t>
<t tx="sta.20200612044656.1">@language c

@doc

This section includes code that is workging and not working that is redundant, or perhaps not required now, or that merely served, at some point, to test or illustrate something.

There is no requirement to 'graduate' code from here. 

@</t>
<t tx="sta.20200612044825.1"></t>
<t tx="sta.20200612044941.1">cdef send2(self, str name, list args):
    _args = [name] + args
    px.py_send_from_seq(self.obj, &lt;PyObject*&gt;_args)
</t>
<t tx="sta.20200612045044.1">@language cython


</t>
<t tx="sta.20200612045651.1">/*--------------------------------------------------------------------------*/
// METHODS

/* common handlers */
void py_handle_float_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_long_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_string_output(t_py* x, PyObject* pval, bool free_now);
void py_handle_list_output(t_py* x, PyObject* pval, bool free_now);

/* core python methods */
void py_eval2(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_exec2(t_py* x, t_symbol* s, long argc, t_atom* argv);

/* extra python methods */
void py_code(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_globex(t_py* x, long n);

/* informational */

/* testing */

/* interobject communications */
void py_lookup(t_py* x, t_symbol* s);

/* code editor */
void py_locatefile(t_py* x, char* filename);

// helpers for api
void py_send_from_seq(t_py* x, PyObject* seq);
t_atom* py_list_to_atom(t_py* x, PyObject* plist);
void py_list_to_atom2(t_py* x, PyObject* plist, long* argc, t_atom** argv);
</t>
<t tx="sta.20200612051513.1">void py_handle_output(t_py* x, PyObject* pval)
{

    // handle ints and longs
    if (PyLong_Check(plong)) {
        long long_result = PyLong_AsLong(plong);
        if (long_result == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        outlet_int(x-&gt;p_outlet_left, long_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    // handle floats and doubles
    if (PyFloat_Check(pfloat)) {
        float float_result = (float)PyFloat_AsDouble(pfloat);
        if (float_result == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }
        outlet_float(x-&gt;p_outlet_left, float_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    // handle strings
    if (PyUnicode_Check(pstring)) {
        const char* unicode_result = PyUnicode_AsUTF8(pstring);
        if (unicode_result == NULL) {
            goto error;
        }
        outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
        outlet_bang(x-&gt;p_outlet_right);
    }

    /* handle any sequence except strings, and presently
       bytes and byte arrays (until there is a reason to)
    */
    if (PySequence_Check(pval) &amp;&amp; !PyUnicode_Check(pval)
        &amp;&amp; !PyBytes_Check(pval) &amp;&amp; !PyByteArray_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);

        if (seq_size &lt;= 0) {
            py_error(
                x, "cannot convert python sequence with length &lt;= 0 to atoms");
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                if (long_item == -1) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check(item) {
                float float_item = PyFloat_AsDouble(item);
                if (float_item == -1.0) {
                    if (PyErr_Occurred())
                        goto error;
                }
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check(item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                if (unicode_item == NULL) {
                    goto error;
                }
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }

        outlet_list(x-&gt;p_outlet_left, NULL, i, atoms);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }
    // final cleanup
    Py_XDECREF(pval);
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}</t>
<t tx="sta.20200612055834.1">@language cython


</t>
<t tx="sta.20200612055834.2"># CRITICAL: STILL CRASHING, works but then crashes!!
cdef send3(self, str name, list args):
    _args = [name] + args
    cdef long argc = &lt;long&gt;len(_args)
    cdef mx.t_atom* argv = px.py_list_to_atom(self.obj, &lt;PyObject*&gt;_args)
    px.py_send(self.obj, mx.gensym(""), argc, argv)
    for i in range(argc):
        mx.sysmem_freeptr(&amp;argv[i])
    mx.sysmem_freeptr(argv)</t>
<t tx="sta.20200612065639.1">#define PY_SSIZE_T_CLEAN
#include "Python.h"

const char* NAME_INT = "INT";
const char* NAME_STR = "STR";
const char* NAME_LST = "LST";
const char* NAME_TUP = "TUP";
const char* NAME_MAP = "MAP";



@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200612065729.1">@path source/py</t>
<t tx="sta.20200612065752.1">
// global identifiers which can be read and written to from c
const char* NAME_INT;
const char* NAME_STR;
const char* NAME_LST;
const char* NAME_TUP;
const char* NAME_MAP;

// use as (PyImport_AppendInittab("globex", PyInit_globex)
PyMODINIT_FUNC PyInit_globex(void);
@language c
@tabwidth -4
</t>
<t tx="sta.20200612065813.1">static PyMethodDef globex_methods[] = {
    { NULL, NULL, 0, NULL } /* Sentinel */
};

</t>
<t tx="sta.20200612065813.2">static PyModuleDef globex_module = {
    PyModuleDef_HEAD_INIT,
    "globex",
    "Examples of global values in a module.",
    -1,
    globex_methods, /* globex_methods */
    NULL,
    NULL,
    NULL,
    NULL,
};

/* Add a dict of {str : int, ...}.
 * Returns 0 on success, 1 on failure.
 */
</t>
<t tx="sta.20200612065813.3">int _add_map_to_module(PyObject* module)
{
    int ret = 0;
    PyObject* pMap = NULL;

    pMap = PyDict_New();
    if (!pMap) {
        goto except;
    }
    /* Load map. */
    if (PyDict_SetItem(pMap, PyBytes_FromString("66"), PyLong_FromLong(66))) {
        goto except;
    }
    if (PyDict_SetItem(pMap, PyBytes_FromString("123"),
                       PyLong_FromLong(123))) {
        goto except;
    }
    /* Add map to module. */
    if (PyModule_AddObject(module, NAME_MAP, pMap)) {
        goto except;
    }
    ret = 0;
    goto finally;
except:
    Py_XDECREF(pMap);
    ret = 1;
finally:
    return ret;
}

PyMODINIT_FUNC PyInit_globex(void)
{
    PyObject* m = NULL;

    m = PyModule_Create(&amp;globex_module);

    if (m == NULL) {
        goto except;
    }
    /* Adding module globals */
    if (PyModule_AddIntConstant(m, NAME_INT, 42)) {
        goto except;
    }
    if (PyModule_AddStringConstant(m, NAME_STR, "String value")) {
        goto except;
    }
    if (PyModule_AddObject(m, NAME_TUP, Py_BuildValue("iii", 66, 68, 73))) {
        goto except;
    }
    if (PyModule_AddObject(m, NAME_LST, Py_BuildValue("[iii]", 66, 68, 73))) {
        goto except;
    }
    /* An invented convenience function for this dict. */
    if (_add_map_to_module(m)) {
        goto except;
    }

    goto finally;
except:
    Py_XDECREF(m);
    m = NULL;
finally:
    return m;
}
</t>
<t tx="sta.20200612114958.1">float pfloat_to_cfloat(t_py* x, PyObject* pfloat)
{
    if (pfloat == NULL)
        goto error;
    
    if PyFloat_Check(pfloat) {
        float cfloat = PyFloat_AsDouble(pfloat);
        if (cfloat == -1.0) {
            if (PyErr_Occurred())
                goto error;
        }
        Py_XDECREF(pfloat);
        return cfloat;
    }

error:
    py_handle_error(x, "float conversion error");
    Py_XDECREF(pfloat);
    return -1.0;
}

void py_handle_float_output(t_py* x, PyObject* pfloat)
{
    float cfloat = pfloat_to_cfloat(x, pfloat); 
    outlet_float(x-&gt;p_outlet_left, cfloat);
    outlet_bang(x-&gt;p_outlet_right);
}</t>
<t tx="sta.20200612115000.1">long plong_to_clong(t_py* x, PyObject* plong)
{
    if (plong == NULL)
        goto error;

    if (PyLong_Check(plong)) {
        long clong = PyLong_AsLong(plong);
        if (clong == -1) {
            if (PyErr_Occurred())
                goto error;
        }
        Py_XDECREF(plong);
        return clong;
    }

error:
    py_handle_error(x, "long conversion error");
    Py_XDECREF(plong);
    return -1;
}

void py_handle_long_output(t_py* x, PyObject* plong)
{
    long clong = plong_to_clong(x, plong); 
    outlet_float(x-&gt;p_outlet_left, clong);
    outlet_bang(x-&gt;p_outlet_right);
}</t>
<t tx="sta.20200612115112.1">const char* pstring_to_cstring(t_py* x, PyObject* pstring)
{
    if (pstring == NULL) {
        goto error;
    }

    if (PyUnicode_Check(pstring)) {
        const char* cstring = PyUnicode_AsUTF8(pstring);
        if (cstring == NULL) {
            goto error;
        }
        Py_XDECREF(pstring);
        return cstring;
    }

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pstring);
    return NULL;
}


void py_handle_string_output(t_py* x, PyObject* pstring) {
    const char* cstring = plong_to_clong(x, pstring);
    outlet_anything(x-&gt;p_outlet_left, gensym(cstring), 0, NIL);
    outlet_bang(x-&gt;p_outlet_right);
}
</t>
<t tx="sta.20200615052024.1">void py_init_builtins(t_py* x)
{
    PyObject* p_name = NULL;
    PyObject* builtins = NULL;
    int err = -1;

    p_name = PyUnicode_FromString(x-&gt;p_name-&gt;s_name);
    if (p_name == NULL)
        goto error;

    builtins = PyEval_GetBuiltins();
    if (builtins == NULL)
        goto error;

    err = PyDict_SetItemString(builtins, "PY_OBJ_NAME", p_name);
    if (err == -1)
        goto error;

    err = PyDict_SetItemString(x-&gt;p_globals, "__builtins__", builtins);
    if (err == -1)
        goto error;

    Py_XDECREF(p_name);
    // Py_XDECREF(builtins);
    return;

error:
    py_handle_error(x, "could not update object namespace with object name");
    Py_XDECREF(p_name);
    // Py_XDECREF(builtins);
}</t>
<t tx="sta.20200615052054.1">void py_locate_path_from_symbol(t_py* x, t_symbol* s)
{
    t_max_err err;

    if (s == gensym("")) { // if no arg supplied ask for file
        x-&gt;p_code_filename[0] = 0;

        if (open_dialog(x-&gt;p_code_filename, &amp;x-&gt;p_code_path,
                        &amp;x-&gt;p_code_outtype, &amp;x-&gt;p_code_filetype, 1))
            // non-zero: cancelled
            return;

    } else {
        // must copy symbol before calling locatefile_extended
        strncpy_zero(x-&gt;p_code_filename, s-&gt;s_name, MAX_PATH_CHARS);
        if (locatefile_extended(x-&gt;p_code_filename, &amp;x-&gt;p_code_path, 
                                &amp;x-&gt;p_code_outtype, &amp;x-&gt;p_code_filetype, 1)) {
            // nozero: not found
            py_error(x, "can't find file %s", s-&gt;s_name);
            return;
        } else {
            err = path_toabsolutesystempath(x-&gt;p_code_path, 
                                            x-&gt;p_code_filename, 
                                            x-&gt;p_code_pathname);
            if (err != MAX_ERR_NONE) {
                py_error(x, "can't convert %s to absolutepath", s-&gt;s_name);
                return;
            }
        }

        // success
        // set attribute from pathname symbol
        x-&gt;p_code_filepath = gensym(x-&gt;p_code_pathname);
    }
}

</t>
</tnodes>
</leo_file>
