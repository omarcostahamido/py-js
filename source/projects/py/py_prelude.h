// py_prelude.h: pure python functions for the `py` external
// generated by `py/scripts/py2c.py`

static const char* PY_PRELUDE_MODULE =
"import os\n"
"import subprocess\n"
"import shlex\n"
"\n"
"# ---------------------------------------------------------\n"
"# global constants\n"
"\n"
"EDITOR = \"Sublime Text\"  # can be changed of course\n"
"\n"
"\n"
"# ---------------------------------------------------------\n"
"# misc funcs\n"
"\n"
"\n"
"def edit(path: str):\n"
"    editor = os.getenv(\"EDITOR\", EDITOR)\n"
"    path = os.path.expanduser(path)\n"
"    shell(f'open -a \"{editor}\" \"{path}\"')\n"
"\n"
"\n"
"# ---------------------------------------------------------\n"
"# funcs are used by methods\n"
"\n"
"\n"
"def shell(cmd: str, err_func=None):\n"
"    result = None\n"
"    try:\n"
"        elems = shlex.split(cmd)\n"
"        elems[-1] = os.path.expanduser(elems[-1])  # ~/a/b.c -> /Users/xx/a/b.c\n"
"        result = subprocess.check_output(elems, encoding=\"utf8\").strip()\n"
"    except subprocess.CalledProcessError as e:\n"
"        if err_func:\n"
"            err_func(e.stderr)\n"
"    except FileNotFoundError as e:\n"
"        if err_func:\n"
"            err_func(e.strerror)\n"
"    if result:\n"
"        return result\n"
"\n"
"\n"
"def out_dict(py_dict: dict):\n"
"    res = []\n"
"    for k, v in py_dict.items():\n"
"        res.append(k)\n"
"        res.append(\":\")\n"
"        if type(v) in [list, set, tuple]:\n"
"            for i in v:\n"
"                res.append(i)\n"
"        else:\n"
"            res.append(v)\n"
"    return res\n"
"\n"
"\n"
"def pipe(s: str):\n"
"    \"\"\"pipe a variable through a list of functions\n"
"\n"
"    >>> pipe('10 math.sin math.cos')\n"
"    0.8556343548213665\n"
"\n"
"    :param      s:    { parameter_description }\n"
"    :type       s:    { type_description }\n"
"    \"\"\"\n"
"    str_args = s.split()\n"
"    val = eval(str_args[0], locals(), globals())\n"
"    funcs = [eval(f, locals(), globals()) for f in str_args[1:]]\n"
"    for f in funcs:\n"
"        val = f(val)\n"
"    return val\n"
"\n"
"\n"
"def rpipe(s: str):\n"
"    \"\"\"pipe a list of variables through a list of functions\n"
"\n"
"    >>> rpipe('math.sin math.cos 10 20 30')\n"
"    0.8556343548213665\n"
"\n"
"    :param      s:    { parameter_description }\n"
"    :type       s:    { type_description }\n"
"    \"\"\"\n"
"    str_args = s.split()\n"
"    fs = []\n"
"    vs = []\n"
"    objs = [eval(x, locals(), globals()) for x in str_args]\n"
"    for i in objs:\n"
"        if isinstance(i, (types.FunctionType, types.BuiltinFunctionType)):\n"
"            fs.append(i)\n"
"        else:\n"
"            vs.append(i)\n"
"    for f in reversed(fs):\n"
"        vs = list(map(f, vs))\n"
"    return vs\n"
"\n"
"def sumpipe(s):\n"
"    \"\"\"pipe a list of variables through a list of functions and sum the result\n"
"\n"
"    >>> sumpipe('math.sin math.cos 10 20 30')\n"
"    0.19353298442897152\n"
"\n"
"    :param      s:    { parameter_description }\n"
"    :type       s:    { type_description }\n"
"    \"\"\"\n"
"    return sum(rpipe(s))\n"
"\n"
"\n"
"def call(s: str):\n"
"    \"\"\"\n"
"    Applies args to a function\n"
"\n"
"    >>> call('sum 1 2 3')\n"
"    6\n"
"    \n"
"    >>> f = lambda *args, **kwargs: print(args, kwargs)\n"
"\n"
"    >>> call('f 10 20 a=1')\n"
"    (10, 20) {'a': 1}\n"
"    \n"
"    :param      s:    { parameter_description }\n"
"    :type       s:    { type_description }\n"
"    \"\"\"\n"
"    str_args = s.split()\n"
"    args = []\n"
"    kwargs = []\n"
"    # if len(str_args) > 2:\n"
"    f = eval(str_args[0], locals(), globals())\n"
"    for str_arg in str_args[1:]:\n"
"        if '=' in str_arg:\n"
"            k, v = str_arg.split('=')\n"
"            kwargs.append((\n"
"                eval(repr(k), locals(), globals()),\n"
"                eval(v, locals(), globals())\n"
"            ))\n"
"        else:\n"
"            args.append(eval(str_arg, locals(), globals()))\n"
"    try:\n"
"        return f(*args, **dict(kwargs))\n"
"    except TypeError:\n"
"        return f(args, **dict(kwargs))\n"
"    except:\n"
"        return f(args[0])\n"
"\n"
"\n";
