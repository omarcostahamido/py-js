./py.c(42)
./py.c(29)
    char msg[50];
    va_list va;
    va_start(va, fmt);
    vsprintf(msg, fmt, va);
    va_end(va);

./py.c(1020)
./py.c(1009)
        if (msg_sym == NULL) { 
            goto error;
        argc = argc - 1;
        argv = argv + 1;
        break;

./py.c(1182)
./py.c(1171)
        if (msg_sym == NULL) { 
            goto error;
        argc = argc - 1;
        atoms = atoms + 1;
        break;

./py.c(618)
./py.c(566)
    Py_DECREF(pval);
    outlet_bang(x->p_outlet_right);
    return;
error:

./py.c(545)
./py.c(485)
    long textsize = 0;
    char* text = NULL;
    PyObject* pval = NULL;
    t_max_err err;
    err = atom_gettext(argc, argv, &textsize, &text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE && textsize && text) {

./py.c(559)
./py.c(502)
    if (pval == NULL) {
        sysmem_freeptr(text);
        goto error;
    sysmem_freeptr(text);

./py.c(778)
./py.c(658)
        goto error;
    for (int i = 1; i < argc; i++) {
        switch ((argv + i)->a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {

./py.c(793)
./py.c(671)
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;

./py.c(804)
./py.c(682)
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)->s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;

./py.c(816)
./py.c(694)
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)->s_name);
            break;
        default:
            py_log(x, "cannot process unknown type");
            break;

./py.c(766)
./py.c(640)
    if (argv->a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;
    } else {

./py.c(1136)
./py.c(974)
    if (obj_name == NULL) {
        goto error;
    if (hashtab_getsize(py_global_registry) == 0) {
        py_scan(x);
    err = hashtab_lookup(py_global_registry, gensym(obj_name), &obj);
    if (err != MAX_ERR_NONE || obj == NULL) {
        py_error(x, "no object found in the registry");
        goto error;

./py.c(1156)
./py.c(994)
        if (msg_sym == NULL) { 
            goto error;
        if (argc - 2 == 0) { //
            argc = 0;

./py.c(1167)
./py.c(1005)
        break;
    case A_FLOAT: {
        msg_sym = gensym("float");
        if (msg_sym == NULL) { 
            goto error;
        argc = argc - 1;

./py.c(1178)
./py.c(1016)
        break;
    case A_LONG: {
        msg_sym = gensym("int");
        if (msg_sym == NULL) { 
            goto error;
        argc = argc - 1;

./py.c(1189)
./py.c(1027)
        break;
    default:
        py_log(x, "cannot process unknown type");
        break;
    t_messlist* messlist = object_mess((t_object*)obj, msg_sym);
    if (messlist) {
        post("messlist->m_sym  (name of msg): %s", messlist->m_sym->s_name);
        post("messlist->m_type (type of msg): %d", messlist->m_type[0]);

./py.c(1123)
./py.c(956)
    t_object* obj = NULL;
    char* obj_name = NULL;
    t_symbol* msg_sym = NULL;
    t_max_err err = NULL;

./py.c(1220)
./py.c(1048)
    return;
error:
    py_error(x, "send failed");
    return;

./py.c(313)
./py.c(42)
        char msg[50];
        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

./py.c(1027)
./py.c(818)
        break;
    default:
        py_log(x, "cannot process unknown type");
        break;

./py.c(313)
./py.c(29)
        char msg[50];
        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

./py.c(1027)
./py.c(696)
        break;
    default:
        py_log(x, "cannot process unknown type");
        break;

./py.c(1189)
./py.c(818)
        break;
    default:
        py_log(x, "cannot process unknown type");
        break;

./py.c(1189)
./py.c(696)
        break;
    default:
        py_log(x, "cannot process unknown type");
        break;

./py.c(1095)
./py.c(397)
        goto error;
    while ((item = PyIter_Next(iter)) != NULL) {
        if (PyLong_Check(item)) {
            long long_item = PyLong_AsLong(item);
            atom_setlong(atoms + i, long_item);
            py_log(x, "%d long: %ld\n", i, long_item);
            i++;
        if PyFloat_Check (item) {
            float float_item = PyFloat_AsDouble(item);
            atom_setfloat(atoms + i, float_item);
            py_log(x, "%d float: %f\n", i, float_item);
            i++;
        if PyUnicode_Check (item) {
            const char* unicode_item = PyUnicode_AsUTF8(item);
            py_log(x, "%d unicode: %s\n", i, unicode_item);
            atom_setsym(atoms + i, gensym(unicode_item));
            i++;
        Py_DECREF(item);

./py.c(1069)
./py.c(370)
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;
    t_atom atoms_static[PY_MAX_ATOMS];
    t_atom* atoms = NULL;
    int is_dynamic = 0;

./py.c(1210)
./py.c(425)
    outlet_bang(x->p_outlet_right);
    py_log(x, "end iter op: %d", i);
    if (is_dynamic) {
        py_log(x, "restoring to static atom array");
        atom_dynamic_end(atoms_static, atoms);

Configuration: 
  Number of files: 1
  Minimal block size: 4
  Minimal characters in line: 3
  Ignore preprocessor directives: 0
  Ignore same filenames: 0

Results: 
  Lines of code: 830
  Duplicate lines of code: 159
  Total 27 duplicate block(s) found.

